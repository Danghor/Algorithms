\documentclass{article}
\usepackage{german}
\usepackage[latin1]{inputenc}
\usepackage{fancyvrb}
\usepackage{a4wide}
\usepackage{amssymb}
\usepackage{epsfig}

\setlength{\textwidth}{15cm}

\newcommand{\bruch}[2]{\frac{\displaystyle \raisebox{1pt}[0pt][-0pt]{$\,#1\,$}}{\displaystyle \raisebox{0pt}[9pt]{$\,#2\,$}}}
\newcommand{\cq}{\symbol{34}}
\newcommand{\Ll}{{\cal L}}
\newcommand{\Rl}{{\cal R}}
\newcommand{\NS}{{\cal N\!S}}
\newcommand{\cl}[1]{{\cal #1}}
\renewcommand{\labelenumi}{(\alph{enumi})}
\renewcommand{\labelenumii}{\arabic{enumii}.}

\newcounter{aufgabe}

\newcommand{\exercise}{\vspace*{0.2cm}
\stepcounter{aufgabe}

\noindent
\textbf{Aufgabe \arabic{aufgabe}}: }

\newcommand{\solution}{\vspace*{0.2cm}

\noindent
\textbf{L\"osung}: }

\begin{document}

\noindent
{\large Aufgaben mit L\"osung zur Vorlesung  ``{\sl Algorithmen und Datenstrukturen}''}
\vspace{0.5cm}


\exercise
\begin{enumerate}
\item L\"osen Sie die Rekurrenz-Gleichung \\[0.2cm]
      \hspace*{1.3cm} $a_{n+2} = a_n + 2$ \\[0.2cm]
      f\"ur die Anfangs-Bedingungen $a_0 = 2$ und $a_1 = 1$.
      \hspace*{\fill} (10 Punkte)
\item L\"osen Sie die Rekurrenz-Gleichung \\[0.2cm]
      \hspace*{1.3cm} $a_{n+2} = 2 \cdot a_n - a_{n+1}$ \\[0.2cm]
      f\"ur die Anfangs-Bedingungen $a_0 = 0$ und $a_1 = 3$.
      \hspace*{\fill} (10 Punkte)
\end{enumerate}
\vspace{0.1cm}

\noindent
\textbf{L\"osung}:
\begin{enumerate}
\item Es handelt sich um eine lineare, inhomogene Rekurrenz-Gleichung der Ordnung 2.
      Die zugeh\"orige homogene Rekurrenz-Gleichung lautet
      \\[0.2cm]
      \hspace*{1.3cm}
      $a_{n+2} = a_n$
      \\[0.2cm]
      Zur L\"osung machen wir den Ansatz $a_n = \lambda^n$.  Das f\"uhrt auf die Gleichung
      \\[0.2cm]
      \hspace*{1.3cm}
      $\lambda^{n+2} = \lambda^n$.
      \\[0.2cm]
      Division durch $\lambda^n$ liefert (nach Umstellen) die Gleichung
      \\[0.2cm]
      \hspace*{1.3cm}
      $\lambda^2 - 1 = 0$.
      \\[0.2cm]
      Wegen $\lambda^2 - 1 = (\lambda - 1) \cdot (\lambda + 1)$ ist diese Gleichung \"aquivalent zu
      \\[0.2cm]
      \hspace*{1.3cm}
      $(\lambda - 1) \cdot (\lambda + 1) = 0$
      \\[0.2cm]
      und daraus folgt
      \\[0.2cm]
      \hspace*{1.3cm}
      $\lambda = 1 \vee \lambda = - 1$.
      \\[0.2cm]
      Um eine spezielle L\"osung der inhomogenen Rekurrenz-Gleichung $a_{n+2} = a_n +2$ zu erhalten,
      versuchen wir zun\"achst den Ansatz $a_n = c$.  Dieser Ansatz f\"uhrt auf die Gleichung
      \\[0.2cm]
      \hspace*{1.3cm}
      $c = c + 2$ \quad aus der sofort die offensichtlich falsche Gleichung \quad $0 = 2$
      \\[0.2cm]
      folgen w\"urde.  Daher f\"uhrt dieser Ansatz nicht zum Ziel und wir versuchen statt dessen den Ansatz
      \\[0.2cm]
      \hspace*{1.3cm}
      $a_n = c \cdot n$.
      \\[0.2cm]
      Damit erhalten wir
      \\[0.2cm]
      \hspace*{1.3cm}
      $c \cdot (n+2) = c \cdot n + 2$.
      \\[0.2cm]
      Die L\"osung dieser Gleichung ist offenbar $c = 1$.
      Damit lautet  die allgemeine L\"osung der Rekurrenz-Gleichung
      \\[0.2cm]
      \hspace*{1.3cm} $a_{n} = \alpha \cdot  1^n + \beta \cdot  (-1)^n + n$.
      \\[0.2cm]
      Die Koeffizienten $\alpha$ und $\beta$ bestimmen wir durch Einsetzen der
      Anfangsbedingungen. Das f\"uhrt auf das Gleichungs-System 
      \\[0.2cm]
      \hspace*{1.3cm}
      $
      \left\{\begin{array}[c]{lcl}
        2 = \alpha + \beta \\
        1 = \alpha - \beta + 1 \\
      \end{array}\right\} \quad \Leftrightarrow\quad
      \left\{\begin{array}[c]{lcl}
        3 = 2\cdot \alpha + 1 \\
        1 = 2\cdot \beta  - 1 \\
      \end{array}\right\} \quad \Leftrightarrow\quad
      \left\{\begin{array}[c]{lcl}
        1 = \alpha  \\
        1 = \beta \\
      \end{array}\right\} 
      $
      \\[0.2cm]
      Damit haben wir folgende L\"osung der gegebenen Rekurrenz-Gleichung gefunden: 
      \\[0.2cm]
      \hspace*{1.3cm} $a_n = (-1)^n + n + 1$.
\item Wir machen den Ansatz $a_n = \lambda^n$ und erhalten die Gleichung
      \\[0.2cm]
      \hspace*{1.3cm}
      $\lambda^{n+2} = 2 \cdot \lambda^n - \lambda^{n+1}$.
      \\[0.2cm]
      Division durch $\lambda^n$ und anschlie{\ss}endes Umstellen liefert
      \\[0.2cm]
      \hspace*{1.3cm}
      $\lambda^2 + \lambda - 2 = 0 \quad \Leftrightarrow\quad (\lambda - 1) \cdot (\lambda + 2) = 0$.
      \\[0.2cm]
      Damit gilt also
      \\[0.2cm]
      \hspace*{1.3cm}
      $\lambda = 1 \vee \lambda = - 2$
      \\[0.2cm]
      und die allgemeine L\"osung lautet
      \\[0.2cm]
      \hspace*{1.3cm} $a_n = \alpha \cdot  1^n + \beta \cdot  (-2)^n$. \\[0.2cm]
      Wir bestimmen die Konstanten $\alpha$ und $\beta$ durch Einsetzen
      der Anfangsbedingungen: 
      \\[0.2cm]
      \hspace*{1.3cm}
       $
      \left\{\begin{array}[c]{lcl}
        0 = \alpha + \beta \\
        3 = \alpha - 2\cdot \beta \\
      \end{array}\right\} \quad \Leftrightarrow\quad
      \left\{\begin{array}[c]{lcl}
        \alpha = -\beta \\
        3 = -3\cdot \beta  \\
      \end{array}\right\} \quad \Leftrightarrow\quad
      \left\{\begin{array}[c]{lcl}
        -1 = \beta  \\
        1 = \alpha \\
      \end{array}\right\} 
      $
      \\[0.2cm]
      Damit erhalten wir die L\"osung 
      \\[0.2cm]
      \hspace*{1.3cm} $a_n = 1 - (-2)^n$.
\end{enumerate}


\textbf{Hinweis}: Bei der L\"osung der folgenden Aufgabe sind selbstverst\"andlich
die in der Vorlesung vorgestellten Algorithmen zu verwenden.
\vspace{0.3cm}


\exercise
 Der AVL-Baum $t$ sei durch den folgenden Term gegeben,
wobei zur Vereinfachung auf die Angabe der Werte, die mit den Schl\"usseln
assoziiert sind, verzichtet wurde.
\\[0.2cm]
\hspace*{1.3cm}
$t = \textsl{node}(17, 
           \textsl{node}(8, 
               \textsl{node}(2, \textsl{nil}, \textsl{nil}),
               \textsl{node}(10, \textsl{nil}, \textsl{nil})), 
           \textsl{node}(23,\textsl{nil},\textsl{nil}))$
%\epsfig{file=avl1,scale=0.5}
\begin{enumerate}
\item F\"ugen Sie  in diesem Baum den Schl\"ussel \texttt{13} ein und geben Sie den
      resultierenden Baum an.   \\[0.2cm]
      \hspace*{\fill} (6 Punkte)
\item F\"ugen Sie in dem Baum aus Teil (b) den Schl\"ussel \texttt{15} ein und geben Sie den
      resultierenden Baum an.
      \hspace*{\fill} (3 Punkte)
\item Entfernen Sie den Schl\"ussel 2 aus dem unter Teil (b) berechneten Baum und geben Sie
      den resultierenden Baum an.
      \hspace*{\fill} (4 Punkte)
\end{enumerate}

\solution
Die folgende L\"osung ist sehr ausf\"uhrlich.  In der Klausur reicht es aus, die entsprechenden B\"aume anzugeben. 

Das Einf\"ugen und L\"oschen in einem AVL-Baum unterscheidet sich von dem Einf\"ugen und L\"oschen
in einem bin\"aren Baum durch die zus\"atzliche Anwendung der Funktion $\textsl{restore}()$.
Diese Funktion ist durch die folgenden Gleichungen spezifiziert:
\begin{enumerate}
\renewcommand{\labelenumi}{\arabic{enumi}.}
\item $\textsl{nil}.\textsl{restore}() = \textsl{nil}$,
\item $|l.\textsl{height}() - r.\textsl{height}()| \leq 1 \rightarrow \textsl{node}(k,v,l,r).\textsl{restore}() = \textsl{node}(k,v,l,r)$,
\item $\begin{array}[t]{cl}
              & l_1.\textsl{height}() = r_1.\textsl{height}() + 2    \\ 
       \wedge & l_1 = \textsl{node}(k_2,v_2,l_2,r_2)               \\
       \wedge & l_2.\textsl{height}() \geq r_2.\textsl{height}()     \\[0.2cm]
       \rightarrow & \textsl{node}(k_1,v_1,l_1,r_1).\textsl{restore}() = 
                     \textsl{node}\bigl(k_2,v_2,l_2,\textsl{node}(k_1,v_1,r_2,r_1)\bigr)
       \end{array}
      $
\item $\begin{array}[t]{cl}
               & l_1.\textsl{height}() = r_1.\textsl{height}() + 2    \\ 
        \wedge & l_1 = \textsl{node}(k_2,v_2,l_2,r_2)               \\
        \wedge & l_2.\textsl{height}() < r_2.\textsl{height}()     \\
        \wedge & r_2 = \textsl{node}(k_3,v_3,l_3,r_3)               \\
        \rightarrow & \textsl{node}(k_1,v_1,l_1,r_1).\textsl{restore}() = 
                      \textsl{node}\bigl(k_3,v_3,\textsl{node}(k_2,v_2,l_2,l_3),\textsl{node}(k_1,v_1,r_3,r_1) \bigr)
        \end{array}
       $
\item $\begin{array}[t]{cl}
              & r_1.\textsl{height}() = l_1.\textsl{height}() + 2    \\ 
       \wedge & r_1 = \textsl{node}(k_2,v_2,l_2,r_2)               \\
       \wedge & r_2.\textsl{height}() \geq l_2.\textsl{height}()     \\[0.2cm]
       \rightarrow & \textsl{node}(k_1,v_1,l_1,r_1).\textsl{restore}() = 
                     \textsl{node}\bigl(k_2,v_2,\textsl{node}(k_1,v_1,l_1,l_2),r_2\bigr)
       \end{array}
      $
\item $\begin{array}[t]{cl}
               & r_1.\textsl{height}() = l_1.\textsl{height}() + 2    \\ 
        \wedge & r_1 = \textsl{node}(k_2,v_2,l_2,r_2)               \\
        \wedge & r_2.\textsl{height}() < l_2.\textsl{height}()     \\
        \wedge & l_2 = \textsl{node}(k_3,v_3,l_3,r_3)               \\
        \rightarrow & \textsl{restore}\bigl(\textsl{node}(k_1,v_1,l_1,r_1)\bigr) = 
                      \textsl{node}\bigl(k_3,v_3,\textsl{node}(k_1,v_1,l_1,l_3),\textsl{node}(k_2,v_2,r_3,r_2) \bigr)
        \end{array}
       $
\end{enumerate}
Damit lautet die L\"osung der Aufgaben:
\begin{enumerate}
\item Zun\"achst f\"ugen wir den Schl\"ussel 13 ein, ohne auf die Balancierungs-Bedingung zu
      achten.  Wir erhalten den folgenden Term, wobei wir die Knoten noch mit ihren H\"ohen
      annotieren, um sp\"ater die Balancierungs-Bedingung \"uberpr\"ufen zu k\"onnen:
      \\[0.2cm]
      \hspace*{1.3cm}
      $t = n(17, n(8, n(2, *, *):1,
                    n(10, n(13, *, *):1, *):2):3,$ \\
      \hspace*{2.75cm} $
                n(23,*,*):1):4$
      \\[0.2cm]
      Damit sehen wir, dass die Balancierungs-Bedingung an der Wurzel dieses
      Knotens verletzt ist, denn der linke Teilbaum hat eine Tiefe von drei, w\"ahrend der
      rechte Teilbaum eine Tiefe von 1 hat.  Da der rechte Teilbaum des linken Teilbaums
      eine gr\"o{\ss}ere Tiefe hat als der linke Teilbaum, liegt die in Gleichung 4 beschriebene
      Situation vor.  Im Einzelnen gilt:
      \begin{enumerate}
      \item $k_1 = 17$,
      \item $l_1 = n(8, n(2, *, *), n(10, n(13, *, *), *))$,
      \item $k_2 = 8$,
      \item $l_2 = n(2, *, *)$,
      \item $r_2 = n(10, n(13, *, *), *))$,
      \item $k_3 = 10$,
      \item $l_3 = n(13, *, *)$,
      \item $r_3 = *$,
      \item $r_1 = n(23,*,*))$.
      \end{enumerate}
      Damit erhalten wir den AVL-Baum
      \\[0.2cm]
      \hspace*{1.3cm}
      $t = n(10, 
                n(8, 
                    n(2, *, *),
                    *),$ \\
      \hspace*{2.75cm} $
                n(17,n(13, *, *),n(23, *,*)))$
\item F\"ugen wir den Schl\"ussel 15 ein, so erhalten wir 
      \\[0.2cm]
      \hspace*{1.3cm}
      $t = n(10, 
                n(8, 
                    n(2, *, *),
                    *),$ \\
      \hspace*{2.75cm} $
                n(17,
                     n(13, 
                            *, 
                            n(15, *,*)),
                     n(23, *,*)))$
      \\[0.2cm]
      Dies ist bereits ein AVL-Baum.
\item Nachdem wir den Schl\"ussel $2$ entfernt haben, hat der Baum die Form
      \\[0.2cm]
      \hspace*{1.3cm}
      $t = n(10, 
                n(8, 
                    *,
                    *),$ \\
      \hspace*{2.75cm} $
                n(17,
                     n(13, 
                            *, 
                            n(15, *,*)),
                     n(23, *,*)))$
      \\[0.2cm]
      Jetzt ist die Balancierungs-Bedingung an der Wurzel verletzt.
      Ein Aufruf von $\textsl{restore}()$ liefert
      \\[0.2cm]
      \hspace*{1.3cm}
      $t = n(13, n(10, n(8, *, *), *),$ \\
      \hspace*{2.75cm} $
                n(17,
                     n(15, *, *),
                     n(23, *,*)))$.
\end{enumerate}
\vspace{0.3cm}

\exercise
Betrachten Sie das folgende Programm:
\begin{verbatim}
    sum := procedure(n) {
        i := 0;
        s := 0;
        while (i <= n) {
            s := i + s;
            i := i + 1;
        }
        return s;
    }
\end{verbatim}
Die Funktion $\textsl{sum}$ soll die folgende Spezifikation erf\"ullen:
\\[0.2cm]
\hspace*{1.3cm} $\textsl{sum}(n) = \frac{1}{2} \cdot n \cdot (n + 1)$
\begin{enumerate}
\item Weisen Sie mit Hilfe des Hoare-Kalk\"uls nach, dass das Programm korrekt ist.
\item Beweisen Sie mit Hilfe der Methode der symbolischen Programm-Ausf\"uhrung nach,
      dass das Programm korrekt ist.
\end{enumerate}
\vspace{0.3cm}

\noindent
\textbf{L\"osung}:
\begin{enumerate}
\item Zun\"achst der Hoare-Kalk\"ul:
\begin{enumerate}
      \renewcommand{\labelenumii}{\arabic{enumii}.}
\item Wir zeigen als erstes, dass die \texttt{while}-Schleife der Invariante 
      \\[0.2cm]
      \hspace*{1.3cm}
      $I := \bigl(s = \frac{1}{2} \cdot i \cdot (i - 1)\bigr)$ 
      \\[0.2cm]
      gen\"ugt.  
      F\"ur die erste Zuweisung in der Schleife gilt
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{ I \wedge i \leq n \}$ \quad \texttt{s := s + i;} \quad $\{ (I \wedge i \leq n)[s \mapsto s - i] \}$
      \\[0.2cm]
      Wir formen den Ausdruck $\bigl(I \wedge i \leq n\bigr)[s \mapsto s - i]$ um:
      \begin{eqnarray*}
        \bigl(I \wedge i \leq n\bigr)[s \mapsto s - i] 
        & \leftrightarrow & \bigl(s = \frac{1}{2} \cdot i \cdot (i-1) \wedge i \leq n\bigr)[s \mapsto s - i] \\
        & \leftrightarrow & s - i = \frac{1}{2} \cdot i \cdot (i-1) \wedge i \leq n \\
        & \leftrightarrow & s = \frac{1}{2} \cdot i \cdot (i-1) + i \wedge i \leq n \\
        & \leftrightarrow & s = \frac{1}{2} \cdot i \cdot (i+1) \wedge i \leq n \\
      \end{eqnarray*}
      Als n\"achstes betrachten wir die Zuweisung ``\texttt{i := i + 1;}'':
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{ s = \frac{1}{2} \cdot i \cdot (i+1) \wedge i \leq n \}$ \quad \texttt{i := i + 1;} \quad
      $\{ \bigl(s = \frac{1}{2} \cdot i \cdot (i+1)\wedge i \leq n\bigr)[i \mapsto i - 1] \}$ 
      \\[0.2cm]
      Es gilt 
      \begin{eqnarray*}        
      &                 & \bigl(s = \frac{1}{2} \cdot i \cdot (i+1)\wedge i \leq n\bigr)[i \mapsto i - 1] \\
      & \leftrightarrow & s = \frac{1}{2} \cdot (i-1) \cdot i \wedge i - 1 \leq n                         \\
      & \leftrightarrow & s = \frac{1}{2} \cdot i \cdot (i-1) \wedge i \leq n + 1                         
      \end{eqnarray*}
      und damit haben wir die Invariante nachgewiesen.
\item Die Invariante ist zu Beginn der Schleife erf\"ullt, denn zu Beginn der
      Schleife gilt $s = 0$ und $i = 0$ und offenbar gilt
      \\[0.2cm]
      \hspace*{1.3cm}
      $i = 0 \wedge s = 0 \rightarrow s = \frac{1}{2} \cdot (i-1) \cdot i$.
\item Nach Beendigung der Schleife gilt $i = n + 1$ und damit hat die Invariante die Form
      \\[0.2cm]
      \hspace*{1.3cm}
      $s = \frac{1}{2} \cdot \bigl((n+1)-1\bigl) \cdot (n+1) = \frac{1}{2} \cdot n \cdot (n+1)$.
      \\[0.2cm]
      Das ist aber genau die Behauptung.
\end{enumerate}
\item Jetzt die symbolische Programm-Ausf\"uhrung:
      \begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 1.3cm,
                  xrightmargin  = 1.3cm,
                  codes         = {\catcode`_=8\catcode`$=3},
                  commandchars  = \\\{\},
                ]
    unsigned sum(unsigned n) \{
        unsigned i$_0$ = 0;
        unsigned s$_0$ = 0;
        while (i$_0$ <= n) \{
            s$_{k+1}$ = i$_k$ + s$_k$;
            i$_{k+1}$ = i$_k$ + 1;
        \}
        return s$_{K}$;
    \}
    \end{Verbatim} 
    %\$
      Wir zeigen nun, dass f\"ur $s_k$ die folgende Invariante gilt: 
      \\[0.2cm]
      \hspace*{1.3cm}
      $s_k = \frac{1}{2} \cdot (i_{k}-1) \cdot i_k$.
      \renewcommand{\labelenumii}{\arabic{enumii}.}
      \begin{enumerate}
      \item[I.A.:] $k=0$.

            Es gilt $s_0 = 0$ und $i_0 = 0$ und damit folgt sofort
            \\[0.2cm]
            \hspace*{1.3cm} $s_0 = \frac{1}{2} \cdot (i_{0}-1) \cdot i_0$.
      \item[I.S.:] $k \mapsto k+1$ 

            Offenbar gilt $i_{k+1} = i_k + 1$ und damit haben wir 
            \begin{eqnarray*}
              s_{k+1} & = & i_k + s_k \\
            & \stackrel{IV}{=} & i_k + \frac{1}{2} \cdot (i_{k}-1) \cdot i_k \\
            & = & \frac{1}{2} \cdot i_{k} \cdot (i_k + 1) \\
            & = & \frac{1}{2} \cdot (i_{k+1} - 1) \cdot i_{k+1}.
            \end{eqnarray*}
      \end{enumerate}
      Die Schleife wird offenbar $n+1$ mal durchlaufen und es gilt $i_K = n+1$.  Daraus folgt
      \\[0.2cm]
      \hspace*{1.3cm}
      $s_K = s_{n+1} = \frac{1}{2} \cdot (i_{n+1} - 1) \cdot i_{n+1} = \frac{1}{2} \cdot n \cdot (n+1)$.
\end{enumerate}
\vspace{0.3cm}
\pagebreak

\exercise
Im Skript
werden Gleichungen angegeben, die das Einf\"ugen und L\"oschen in einem Heap beschreiben.
In diesem Zusammenhang sollen Sie in dieser Aufgabe  einige zus\"atzliche Methoden auf
bin\"aren B\"aumen durch bedingte Gleichungen spezifizieren.
\begin{enumerate}
\item Spezifizieren Sie eine Methode \textsl{isHeap}, so
      dass f\"ur einen bin\"aren Baum $b \in \mathcal{B}$ der Ausdruck 
      $b.\mathtt{isHeap}()$ genau dann den Wert $\mathtt{true}$ hat, wenn $b$ die
      \emph{Heap-Bedingung} erf\"ullt.  \hspace*{\fill} (10 Punkte)
\item Implementieren Sie eine Methode \textsl{isBalanced}, so
      dass f\"ur einen bin\"aren Baum $b \in \mathcal{B}$ der Ausdruck 
      $b.\mathtt{isBalanced}()$ genau dann den Wert $\mathtt{true}$ hat, wenn $b$ die
      \emph{Balancierungs-Bedingung} f\"ur \emph{Heaps} erf\"ullt.  
      \hspace*{\fill} (5 Punkte)
\end{enumerate}
\vspace{0.3cm}

\noindent
\textbf{L\"osung}:
\begin{enumerate}
\item Um die Methode \textsl{isHeap} leicht spezifizieren zu k\"onnen, definieren wir zun\"achst
      eine Hilfsfunktion
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{isBigger} : \mathcal{B}  \times \textsl{Key}  \rightarrow \mathbb{B}$.
      \\[0.2cm]
      F\"ur einen bin\"aren Baum $b$ und einen Schl\"ussel $k$ soll $b.\textsl{isBigger}(k)$ genau dann gelten,
      wenn alle Schl\"ussel, die in $b$ auftreten, gr\"o{\ss}er-gleich $k$ sind.
      Diese Funktion wird durch Gleichungen spezifiziert:
      \begin{enumerate}
      \item $\textsl{nil}.\textsl{isBigger}(k) = \mathtt{true}$,
      \item $\textsl{node}(k_1,v_1,l,r).\textsl{isBigger}(k) = \bigl(k_1 \geq k_1 \wedge l.\textsl{isBigger}(k) \wedge r.\textsl{isBigger}(k)\bigr)$.
      \end{enumerate}
      Damit l\"asst sich jetzt die Methode $\textsl{isHeap}()$ durch Gleichungen spezifizieren:
      \begin{enumerate}
      \item $\textsl{nil}.\textsl{isHeap}() = \mathtt{true}$,
      \item $\textsl{node}(k,v,l,r).\textsl{isHeap}() = 
             \bigl(l.\textsl{isBigger}(k) \wedge r.\textsl{isBigger}(k) \wedge l.\textsl{isHeap}() \wedge r.\textsl{isHeap}()\bigr)$.
      \end{enumerate}
\item Wir definieren die Methode $\textsl{isBalanced}()$ induktiv.
      \begin{enumerate}
      \item $\textsl{nil}.\textsl{isBalanced}() = \mathtt{true}$,
      \item $\textsl{node}(k,v,l,r).\textsl{isBalanced}() =$ \\[0.1cm]
            \hspace*{\fill}
            $\bigl(|l.\textsl{count}() - r.\textsl{count}()| \leq 1 
             \wedge l.\textsl{isBalanced}()\wedge r.\textsl{isBalanced}()\bigr)$.
      \end{enumerate}
      Hier haben wir eine Hilfsfunktion $\textsl{count}$ benutzt, die wie folgt spezifiziert werden kann:
      \begin{enumerate}
      \item $\textsl{Nil}.\textsl{count}() = 0$
      \item $\textsl{Node}(p,v,l,r).\textsl{count}() = 1 + l.\textsl{count}() + r.\textsl{count}()$.
      \end{enumerate}
\end{enumerate}
\pagebreak

\exercise
Es sei 
$f(n) := \biggl(\sum\limits_{i=1}^n \frac{1}{i}\biggr) - \ln(n)$.
Zeigen Sie $f(n)\in \mathcal{O}\bigl(1\bigr)$. \hspace*{\fill} (12 Punkte)

\noindent
\textbf{Hinweis}:  Zeigen Sie 
\\[0.2cm]
\hspace*{1.3cm}
$0 \leq \biggl(\sum\limits_{i=1}^n \frac{1}{i}\biggr) - \ln(n) \leq 1$.

\solution
F\"ur alle $x \in [i-1,i]$ gilt:
\begin{eqnarray*}
&             & x \leq i \\[0.3cm]
& \Rightarrow & \bruch{1}{x} \geq \bruch{1}{i} \\[0.2cm]
& \Rightarrow & \int_{i-1}^i \bruch{1}{x} dx \geq \int_{i-1}^i \bruch{1}{i} dx \\[0.2cm]
& \Rightarrow & \int_{i-1}^i \bruch{1}{x} dx \geq \bruch{1}{i} \\[0.2cm]
& \Rightarrow & \sum\limits_{i=2}^{n} \int_{i-1}^i \bruch{1}{x} dx \geq 
                \sum\limits_{i=2}^{n} \bruch{1}{i}                      \\[0.2cm]
& \Rightarrow & \int_{1}^n \bruch{1}{x} dx \geq \sum\limits_{i=2}^{n} \bruch{1}{i} \\[0.2cm]
& \Rightarrow & \ln(n) - \ln(1) \geq \sum\limits_{i=2}^{n} \bruch{1}{i} \\[0.2cm]
& \Rightarrow & \ln(n) + 1 \geq \sum\limits_{i=1}^{n} \bruch{1}{i} \\[0.2cm]
& \Rightarrow & \sum\limits_{i=1}^{n} \bruch{1}{i} - \ln(n) \leq 1 
\end{eqnarray*}
Analog gilt f\"ur alle $x \in [i-1,i]$:
\begin{eqnarray*}
&             & x \geq i - 1 \\[0.3cm]
& \Rightarrow & \bruch{1}{x} \leq \bruch{1}{i-1} \\[0.2cm]
& \Rightarrow & \int_{i-1}^i \bruch{1}{x} dx \leq \int_{i-1}^i \bruch{1}{i-1} dx \\[0.2cm]
& \Rightarrow & \int_{i-1}^i \bruch{1}{x} dx \leq \bruch{1}{i-1} \\[0.2cm]
& \Rightarrow & \sum\limits_{i=2}^{n} \int_{i-1}^i \bruch{1}{x} dx \leq 
                \sum\limits_{i=2}^{n} \bruch{1}{i-1}                      \\[0.2cm]
& \Rightarrow & \int_{1}^n \bruch{1}{x} dx \leq \sum\limits_{i=2}^{n} \bruch{1}{i-1} \\[0.2cm]
& \Rightarrow & \ln(n) - \ln(1) \leq \sum\limits_{i=2}^{n} \bruch{1}{i-1} \\[0.2cm]
& \Rightarrow & \ln(n) \leq \sum\limits_{i=1}^{n-1} \bruch{1}{i} \\[0.2cm]
& \Rightarrow & 0 \leq \sum\limits_{i=1}^{n-1} \bruch{1}{i} - \ln(n) \\[0.2cm]
& \Rightarrow & 0 \leq \sum\limits_{i=1}^{n} \bruch{1}{i} - \ln(n) 
\end{eqnarray*}
Insgesamt haben wir damit die Ungleichungs-Kette
\\[0.2cm]
\hspace*{1.3cm}
$0 \leq \biggl(\sum\limits_{i=1}^n \frac{1}{i}\biggr) - \ln(n) \leq 1$
\\[0.2cm]
bewiesen und daraus folgt die Behauptung unmittelbar.

\exercise
Es sei $\mathcal{B}$ die Menge der bin\"aren B\"aume, die im Skript definiert wird.  
\begin{enumerate}
\item Spezifizieren Sie eine Methode \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{isOrdered}: \mathcal{B} \rightarrow \mathbb{B}$
      \\[0.2cm]
      durch bedingte Gleichungen.  F\"ur einen bin\"aren Baum $b$ soll der Aufruf
      $b.\textsl{isOrdered}()$ genau dann \texttt{true} zur\"uck liefern, wenn $b\in \mathcal{B}_<$
      gilt.
      \hspace*{\fill} (8 Punkte)

      \textbf{Hinweis}: Definieren Sie sich geeignete Hilfsfunktionen.
\item Es sei $\textsl{insert}()$ die in Abschnitt 7.2 des Skripts definierte Methode.
      Nehmen Sie an, dass Sie f\"ur alle $b\in \mathcal{B}_<$, alle Schl\"ussel $k$ und alle Werte
      $v$ die Gleichung
      \\[0.2cm]
      \hspace*{1.3cm} $b.\textsl{insert}(k,v).\textsl{isOrdered}() = \texttt{true}$
      \\[0.2cm]
      beweisen sollen.  Geben Sie an, welche Lemmata \"uber die in Teil (a) definierten
      Hilfsfunktionen zu einem solchen Beweis ben\"otigt werden.
      \hspace*{\fill} (4 Punkte)
\item Zeigen Sie nun f\"ur geordnete bin\"are B\"aume die Gleichung
      \\[0.2cm]
      \hspace*{1.3cm} $b.\textsl{insert}(k,v).\textsl{isOrdered}() = \texttt{true}$ 
      \hspace*{\fill} (12 Punkte)
      \\[0.2cm]
      Sie d\"urfen dabei die Lemmata, die Sie in Teil (b) angeben sollen, benutzen.
\end{enumerate}

\solution
\begin{enumerate}
\item Wir definieren zun\"achst zwei Hilfsfunktionen
      \\[0.2cm]
      \hspace*{1.3cm} 
      $\textsl{smaller}: \mathcal{B} \times \textsl{Key} \rightarrow \mathbb{B}$ 
      \quad und \quad
      $\textsl{bigger}: \mathcal{B} \times \textsl{Key} \rightarrow \mathbb{B}$.
      \\[0.2cm]
      Der Aufruf $b.\textsl{smaller}(k)$ soll als Ergebnis genau dann \texttt{true}
      liefern, wenn alle in dem Baum $b$ auftretenden Schl\"ussel kleiner als der Schl\"ussel
      $k$ sind.  Analog liefert der Aufruf $b.\textsl{bigger}(k)$  als Ergebnis genau dann \texttt{true},
      wenn alle in dem Baum $b$ auftretenden Schl\"ussel gr\"o{\ss}er als der Schl\"ussel
      $k$ sind.  Die beiden Funktionen werden durch die folgenden Gleichungen definiert:
      \begin{enumerate}
      \item $\textsl{nil}.\textsl{smaller}(k) = \mathtt{true}$.
      \item $\textsl{node}(k_1,v_1,l,r).\textsl{smaller}\bigl(k\bigr) = 
                \bigl(k_1 < k \wedge l.\textsl{smaller}(k) \wedge r.\textsl{smaller}(k)\bigr)$.
      \item $\textsl{nil}.\textsl{bigger}(k) = \mathtt{true}$.
      \item $\textsl{node}(k_1,v_1,l,r).\textsl{bigger}\bigl(k\bigr) = 
             \bigl(k_1 > k \wedge l.\textsl{bigger}(k) \wedge r.\textsl{bigger}(k)\bigr)$.
      \end{enumerate}
      Damit kann nun die Funktion $\textsl{isOrdered}()$ wie folgt spezifiziert werden:
      \begin{enumerate}
      \item $\textsl{nil}.\textsl{isOrdered}() = \mathtt{true}$.
      \item $\textsl{node}(k,v,l,r).\textsl{isOrdered}() = 
             \bigl(l.\textsl{smaller}(k) \wedge r.\textsl{bigger}(k) 
             \wedge l.\textsl{isOrdered}() \wedge r.\textsl{isOrdered}()\bigr)
            $.
      \end{enumerate}
\item Wir ben\"otigen die folgenden beiden Eigenschaften der Funktionen $\textsl{smaller}$ und
      $\textsl{bigger}$:
      \begin{enumerate}
      \item $k < k_1 \wedge l.\textsl{smaller}(k_1) \rightarrow l.\textsl{insert}(k,v).\textsl{smaller}(k_1)$,
      \item $k > k_1 \wedge r.\textsl{bigger}(k_1)  \rightarrow r.\textsl{insert}(k,v).\textsl{bigger}(k_1)$.
      \end{enumerate}
\item Wir f\"uhren den Beweis durch Wert-Verlaufsinduktion.
      \begin{enumerate}
      \item Fall:
            $\textsl{nil}.\textsl{insert}(k,v).\textsl{isOrdered}() =
             \textsl{node}(k,v,\textsl{nil},\textsl{nil}).\textsl{isOrdered}() = \texttt{true}$.
      \item Fall: Es gelte $k < k_1$.  Dann k\"onnen wir voraussetzen, dass
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{node}(k_1,v_1,l,r).\textsl{isOrdered}()$
            \\[0.2cm]
            gilt und m\"ussen zeigen, dass daraus
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{node}(k_1,v_1,l,r).\textsl{insert}(k,v).\textsl{isOrdered}()$
            \\[0.2cm]
            folgt.  Dies sehen wir wie folgt:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\begin{array}[t]{cl}
                & \textsl{node}(k_1,v_1,l,r).\textsl{insert}(k,v).\textsl{isOrdered}() \\[0.2cm]
              = & \textsl{node}(k_1,v_1,l.\textsl{insert}(k,v),r).\textsl{isOrdered}()     \\[0.2cm]
              = & \bigl(l.\textsl{insert}(k,v).\textsl{smaller}(k_1) \wedge
                        r.\textsl{bigger}(k_1) \;\wedge            \\[0.1cm]
                & \;\;  l.\textsl{insert}(k,v).\textsl{isOrdered}()    \wedge
                        r.\textsl{isOrdered}()\bigr)\\[0.2cm]
            \end{array}
            $
            \\[0.2cm]
            Wir zeigen nun, dass alle vier Bestandteile dieser Konjunktion den Wert
            \texttt{true} haben.
            \begin{enumerate}
            \item Aus der Voraussetzung, dass
                  $\textsl{node}(k_1,v_1,l,r).\textsl{isOrdered}()$ gilt, folgt zun\"achst
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $l.\textsl{smaller}(k_1)$.
                  \\[0.2cm]
                  Nach Teil $(b)$ folgt wegen $k < k_1$ dann auch
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $l.\textsl{insert}(k,v).\textsl{smaller}(k_1)$.
            \item Aus der Voraussetzung
                  $\textsl{node}(k_1,v_1,l,r).\textsl{isOrdered}()$ folgt unmittelbar
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $r.\textsl{bigger}(k_1)$.
            \item Aus der Voraussetzung
                  $\textsl{node}(k_1,v_1,l,r).\textsl{isOrdered}()$ folgt zun\"achst
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $l.\textsl{isOrdered}()$.
                  \\[0.2cm]
                  Nach Induktions-Voraussetzung haben wir dann auch
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $l.\textsl{insert}(k,v).\textsl{isOrdered}()$.
            \item Aus der Voraussetzung
                  $\textsl{node}(k_1,v_1,l,r).\textsl{isOrdered}()$ folgt sofort
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $r.\textsl{isOrdered}()$.
            \end{enumerate}
            Damit haben wir insgesamt gezeigt, dass
            $\textsl{node}(k_1,v_1,l.\textsl{insert}(k,v),r).\textsl{isOrdered}()$ gilt.
      \item Fall: Es gelte $k > k_1$.  Dann k\"onnen wir voraussetzen, dass
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{node}(k_1,v_1,l,r).\textsl{isOrdered}()$
            \\[0.2cm]
            gilt und m\"ussen zeigen, dass daraus
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{node}(k_1,v_1,l,r).\textsl{insert}(k,v).\textsl{isOrdered}()$
            \\[0.2cm]
            folgt, was darauf herausl\"auft zu zeigen, dass
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{node}\bigl(k_1,v_1,l,r.\textsl{insert}(k,v)\bigr).\textsl{isOrdered}()$
            \\[0.2cm]
            gilt.  Da die Rechnung analog zum zweiten Fall ist, f\"uhren wir sie nicht weiter aus.
      \end{enumerate}
\end{enumerate}
\pagebreak

\exercise
Es gelte $\Sigma = \{ \mathtt{a},\,\mathtt{b},\,\mathtt{c},\,\mathtt{d},\,\mathtt{e},\,\mathtt{f} \}$.
Die H\"aufigkeit, mit der diese Buchstaben in dem zu kodierenden String $s$ auftreten, sei durch die
folgende Tabelle gegeben:

\begin{center}
\begin{tabular}[t]{|l|r|r|r|r|r|r|}
\hline
Buchstabe  & \texttt{a} & \texttt{b} & \texttt{c} & \texttt{d} & \texttt{e} & \texttt{f} \\
\hline
H\"aufigkeit &          8 &          9 &         10 &         11 &         12 &         13 \\
\hline
\end{tabular}
\end{center}
\begin{enumerate}
\item Berechnen sie einen optimalen Kodierungs-Baum f\"ur die angegebenen H\"aufigkeiten.
\item Geben die Kodierung der einzelnen Buchstaben an, die sich aus diesem Baum ergibt.
\end{enumerate}

\noindent
\textbf{L\"osung}:
\begin{enumerate}
\item Wir wenden den Huffman-Algorithmus an und erhalten die folgenden Mengen.  Zur Abk\"urzung
      schreiben wir dort $l(a,f)$ statt $\textsl{leaf}(a,f)$ und $n(l,r)$ statt $\textsl{node}(l,r)$.
      \begin{enumerate}
      \item $\{ l(a,8), l(b,9), l(c,10), l(d,11), l(e,12), l(f,13) \}$
      \item $\{ l(c,10), l(d,11), l(e,12), l(f,13), n(l(a,8), l(b,9)):17 \}$
      \item $\{ l(e,12), l(f,13), n(l(a,8), l(b,9)):17, n(l(c,10), l(d,11)):21 \}$
      \item $\{ n(l(a,8), l(b,9)):17, n(l(c,10), l(d,11)):21, n(l(e,12), l(f,13)):25 \}$
      \item $\{ n(l(e,12), l(f,13)):25, n(n(l(a,8), l(b,9)):17, n(l(c,10), l(d,11)) :21):38 \}$
      \item $\{ n(n(l(e,12), l(f,13)):25, n(n(l(a,8), l(b,9)):17, n(l(c,10), l(d,11)):21):38):63 \}$
      \end{enumerate}
      Damit ist 
      \\[0.2cm]
      \hspace*{1.3cm} $n(n(l(e,12), l(f,13)), n(n(l(a,8), l(b,9)), n(l(c,10), l(d,11))))$
      \\[0.2cm]
      der gesuchte Kodierungsbaum.
\item Also ergibt sich die folgende Kodierung f\"ur die einzelnen Buchstaben:
      \begin{verbatim}
      e = 00, f = 01, a = 100, b = 101, c = 110, d = 111.
      \end{verbatim}
\end{enumerate}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
