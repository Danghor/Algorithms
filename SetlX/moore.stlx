// Moore's algorithm for computing the shortest path function.
shortestPath := procedure(source, Edges) {
    Dist := {};
    Dist[source] := 0;
    Fringe := { source };
    while (Fringe != {}) {
        u := from(Fringe);
        for ([v,l] in Edges[u] | Dist[v] == om || Dist[u]+l < Dist[v]) {
            Dist[v] := Dist[u] + l;
            Fringe  += { v };
        }
    }
    return Dist;
};
// Code for testing.                                                     
Edges := { ["a", {["b", 2], ["c", 3]}], 
           ["b", {["d", 1]} ],
           ["c", {["e", 3]} ],  
           ["d", {["e", 2], ["f", 4]} ],  
           ["e", {["f", 1]} ],
           ["f", {} ]
         };
m  := { x : [x, _ ] in Edges };
s  := "a";
sp := shortestPath(s, Edges);
for (x in m) {
    print("distance($s$, $x$) = $sp[x]$");
}

