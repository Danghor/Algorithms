\chapter{Abstract Data Types}
In the same way as the notion of an \blue{algorithm} abstracts from the details of a concrete
implementation of this algorithm, the notion of an \href{https://en.wikipedia.org/wiki/Abstract_data_type}{abstract data type} abstracts from the implementation
details of concrete data structures.  Therefore, this notion enables us to separate algorithms from the data
structures used in these algorithms.  The next section gives a formal definition of
abstract data types.  As an example, we introduce the abstract data type of
\href{https://en.wikipedia.org/wiki/Stack_(abstract_data_type)}{stacks}.
The second section shows how abstract data types are supported in \textsl{Python} via \blue{classes}.  Finally,
we show how stacks can be used 
to evaluate \blue{arithmetic expressions}.  To this end we build an
\href{https://en.wikipedia.org/wiki/Operator-precedence_parser}{operator precedence parser}. 

Abstract data types were proposed by 
\href{https://en.wikipedia.org/wiki/Barbara_Liskov}{Barbara Liskov}\footnote{
  Barbara Liskov received the 2008 \href{https://en.wikipedia.org/wiki/Turing_Award}{Turing Award}.}
and Stephen Zilles in 1974 \cite{liskov:1974}.  Abstract data type are one of the two main ingredients of
\blue{object oriented programming}.  The other ingredient is \blue{inheritance}.

\section[Formal Definition]{A Formal Definition of Abstract Data Types}
We define an \blue{abstract data type} $\mathcal{D}$ formally as a 5-tupel of the form \index{abstract data type}
\\[0.2cm]
\hspace*{1.3cm}
 $\mathcal{D} = \langle N, P, \textsl{Fs}, \textsl{Ts}, \textsl{Ax} \rangle$,
\\[0.2cm] 
where the meaning of the components is as follows:
\begin{enumerate}
\item $N$ is a string.  This string is the \blue{name} of the abstract data type.
\item $P$ is the set of \blue{type parameters}.   Here, a type parameter is just a string.
      This string is interpreted as a type variable.  The idea is that we can later substitute 
      a data type for this string.
\item $\textsl{Fs}$ is the set of \blue{function symbols}.  These function symbols denote the 
      operations that are supported by this abstract data type. The function symbols itself are strings.
\item $\textsl{Ts}$ is a set of \blue{type specifications}.  For every function symbol
      $f \in \textsl{Fs}$
      the set $\textsl{Ts}$ contains a \blue{type specifications}\index{type specification} of the form 
      \\[0.2cm]
      \hspace*{1.3cm} 
      $f: T_1 \times \cdots \times T_n \rightarrow S$. 
      \\[0.2cm]
      Here,  $T_1$, $\cdots$, $T_n$ and $S$ are names of data types.  There are three cases for
      these data types: 
      \begin{enumerate}
      \item We can have predefined data types like, e.g.~``\texttt{int}'' or ``\texttt{str}''.
      \item Furthermore, $T_1$, $\cdots$, $T_n$ and $S$ can be the names of abstract data types.
      \item Finally,  $T_1$, $\cdots$, $T_n$ and $S$ can be type parameters from the set $P$.
      \end{enumerate}
      The type specification $f: T_1 \times \cdots \times T_n \rightarrow S$ expresses the fact that
      the function $f$ has to be called as \\[0.2cm] 
      \hspace*{1.3cm}
      $f(t_1,\cdots,t_n)$ 
      \\[0.2cm]
      where the argument $t_i$ has type $T_i$ for all $i \in \{1,\cdots,n\}$.
      Furthermore, the result of the function $f$ is of type $S$.

      Additionally, we must have either $T_1 = N$ or $S = N$.  Therefore, either
      the first argument of $f$ has to be of type $N$ or the result of $f$ has to be of type 
      $N$, where $N$ is the name of the abstract data types $\mathcal{D}$.  If we have  $T_1 \not= N$ and, therefore,
      $S = N$, then $f$ is called a \blue{constructor}\index{constructor} of the abstract data type $N$.  
      Otherwise,  $f$ is called a  \blue{method}.\index{method}
\item $Ax$ is a set of mathematical formulas.   These formulas 
      specify the behaviour of the abstract data type and are therefore called
      the \blue{axioms} of $\mathcal{D}$.
\end{enumerate}
The notion of an \underline{a}bstract \underline{d}ata \underline{t}ype is often abbreviated as \textsc{\blue{Adt}}.
\index{ADT}

Next, we provide a simple example of an abstract data type, the 
\href{https://en.wikipedia.org/wiki/Stack_(abstract_data_type)}{stack}\index{stack}.
Informally, a stack can be viewed as a pile of objects that are put on top of each other, so that
only the element on top of the pile is accessible.  An ostensive example of a stack is a pile of
plates that can be found in a cafeteria.  Usually, the clean plates are placed on top of each other
and only the plate on top is accessible.  Formally, we define the abstract data type
\texttt{Stack}\index{Stack} as follows: 
\begin{enumerate}
\item The name of this abstract data type is \texttt{Stack}.
\item The set of type parameters is $\{ \texttt{Element} \}$.
\item The set of function symbols is \\[0.2cm]
      \hspace*{1.3cm} 
      $\bigl\{ \texttt{stack}, \texttt{push}, \texttt{pop}, \texttt{top}, \texttt{isEmpty} \bigr\}$.
\item The type specifications for these function symbols are given as follows:
      \begin{enumerate}
      \item $\texttt{stack}: \texttt{Stack}$

            The function $\texttt{stack}$ takes no arguments and produces an empty stack.
            Therefore, this function is a \blue{constructor}.  Intuitively, the function call $\texttt{stack}()$ 
            creates an empty stack.
      \item $\texttt{push}: \texttt{Stack} \times \texttt{Element} \rightarrow \texttt{Stack}$

            The function call $\texttt{push}(S,x)$ puts the element $x$ on top of the stack $S$.  In
            the following, we will use \blue{object oriented notation}\index{object oriented notation}
            and write $S.\texttt{push}(x)$ instead of $\texttt{push}(S,x)$.
      \item $\texttt{pop}: \texttt{Stack}  \rightarrow \texttt{Stack}$

            The function call $S.\texttt{pop}()$ removes the topmost element from the stack $S$.
      \item $\texttt{top}: \texttt{Stack} \rightarrow \texttt{Element}$

            The function call $S.\texttt{top}()$ returns the element that is on top of the stack $S$. 
            The stack $S$ is left unchanged.
     \item $\texttt{isEmpty}: \texttt{Stack} \rightarrow \mathbb{B}$

            The Boolean function call $S.\texttt{isEmpty}()$ checks whether the stack $S$ is empty.
      \end{enumerate}
\end{enumerate}
The behaviour of a stack is specified by the following \blue{axioms}.
\begin{enumerate}
\item $\texttt{stack}().\texttt{top}() = \Omega$

      Here, $\Omega$ \index{$\Omega$} denotes the undefined value\footnote{
       Some philosophers are concerned that it is not possible to define an undefined value.
       They argue that if an undefined value could be defined, it would be no longer undefined
       and hence it can not be defined.  However, that is precisely the point of the undefined 
       value: As it cannot be defined, it is undefined. \raisebox{-0.1cm}{$\Large\smiley$}}.\index{undefined value}
      In \textsl{Python}, $\Omega$ is represented as \texttt{None}. The expression $\texttt{stack}()$
      creates an empty stack.  Therefore, the given axiom expresses the fact that there is no
      element on top of the empty stack.
\item $S.\texttt{push}(x).\texttt{top}() = x$

      If we have a stack $S$ and push an element $x$ on top of $S$, then the element on top
      of the resulting stack is, unsurprisingly, $x$.
\item $\texttt{stack}().\texttt{pop}() = \Omega$

      Trying to remove an element from the empty stack yields an undefined result.
\item $S.\texttt{push}(x).\texttt{pop}() = S$

      If we have a stack $S$, push an element $x$ of top of $S$, and finally remove the element
      on top of the resulting stack, then we are back at the original stack $S$.
    
\item $\texttt{stack}().\texttt{isEmpty}() = \texttt{true}$

      This axiom expresses the fact that the stack created by the function call $\texttt{stack}()$
      is empty.
\item $S.\texttt{push}(x).\texttt{isEmpty}() = \texttt{false}$

      If we push an element $x$ on top of a stack $S$, then the resulting stack cannot be empty.
\end{enumerate}
When contemplating the axioms given above, we can recognize some structure.  If we denote the
functions \texttt{stack} and \texttt{push} as \blue{generators},\index{generator}  then the axioms specify the
behaviour of the remaining functions on the stacks created by these generators.

The data type of a stack has many applications in computer science.  To give just one example, the
implementation of the \href{https://en.wikipedia.org/wiki/Java_virtual_machine}{\textsl{Java} virtual machine}
is based on a stack.  Furthermore,  we will later see how,  using three stacks, \blue{arithmetic expressions} can be
\blue{evaluated}. 


\section[Implementation]{Implementing Abstract Data Types in \textsl{Python}}
In object oriented programming languages, abstract data types are conveniently implemented as
\blue{classes}.  In a typed object oriented programming language like \textsl{Java}, the usual way to proceed
is to create an \blue{interface} describing the signatures of the abstract data type and then to implement
the abstract data type as a class.  Instead of an interface, we can also use an \blue{abstract class}
to describe the signatures.  In an untyped language like \textsl{Python} there is no way to
neatly capture the signatures of an abstract data type.  Therefore, the implementation of an abstract data type in
\textsl{Python} merely consists of a class.  At this point we note that classes are discussed in depth in
Chapter 9 of the \textsl{Python}  \href{https://docs.python.org/3.6/tutorial/classes.html}{tutorial}.  These
lecture notes only describe the most basic concepts of \textsl{Python} classes, since this is sufficient for this
lecture.  Further details can also be found in the \textsl{Python}
\href{https://docs.python.org/3.6/reference/index.html}{online reference}. 


\begin{figure}[!h]
  \centering
\begin{minted}[ frame         = lines, 
                framesep      = 0.3cm,
                bgcolor       = sepia,
                numbers       = left,
                numbersep     = -0.2cm,
                xleftmargin   = 0.0cm,
                xrightmargin  = 0.0cm
              ]{python3}
    class Stack:
        def __init__(self):
            self.mStackElements = []
    
        def push(self, e):
            self.mStackElements.append(e)
    
        def pop(self):
            assert len(self.mStackElements) > 0, "popping empty stack"
            self.mStackElements = self.mStackElements[:-1]
    
        def top(self):
            assert len(self.mStackElements) > 0, "top of empty stack"
            return self.mStackElements[-1]
    
        def isEmpty(self):
            return self.mStackElements == []
    
        def copy(self):
            C = Stack()
            C.mStackElements = self.mStackElements[:]
            return C
    
        def __str__(self):
            C = self.copy()
            result = C._convert()
            dashes = "-" * len(result)
            return '\n'.join([dashes, result, dashes])
    
        def _convert(self):
            if self.isEmpty():
                return '|'
            t = self.top()
            self.pop()
            return self._convert() + ' ' + str(t) + ' |'
    
    def createStack(L):
        S = Stack()
        n = len(L)
        for i in range(n):
            S.push(L[i])
            print(S)
        return S
    
    createStack(range(10))
\end{minted}
\vspace*{-0.3cm}
  \caption{An array based implementation of the ADT \textsl{Stack} in \textsl{Python}.}
  \label{fig:stack-array.stlx}
\end{figure} 

Figure \ref{fig:stack-array.stlx} shows an implementation of the ADT \textsl{Stack} that is 
discussed next.
\begin{enumerate}
\item The definition of the \textsc{Adt} \textsl{Stack} starts with the keyword \texttt{class}
      in line 1.
      After the keyword \texttt{class}, the name of the class has to be given.  In Figure
      \ref{fig:stack-array.stlx} this name is \texttt{Stack}.
\item In \textsl{Python}, the \blue{constructor} of a class has the name \texttt{\_\_init\_\_}.
      All methods defined in a class receive the object as their first argument.
      The convention is to name this parameter \texttt{self}, but this is not mandatory.
      The name \texttt{self} is similar to the keyword \texttt{this} in the programming language
      \textsl{Java}.  However, technically the name \texttt{self} is not a keyword in \textsl{Python}.
      
      The constructor receives an \blue{uninitialized} object as its first argument and has the task
      to initialize the \blue{member variables} of this object.  The class \texttt{Stack} uses only one member variable:
      This member variable is called \texttt{mStackElements}.  My convention is to always start member
      variables with the letter '\texttt{m}'.  Another convention is to use the underscore character
      '\texttt{\_}'.  These conventions facilitates the distinction of member variables from local variables.

      In order to create an object of class \texttt{Stack} we invoke the constructor as follows:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{s = Stack()}
      \\[0.2cm]
      This statement creates an uninitialized object (in other words: an empty object) of class \texttt{Stack}
      and then invokes the constructor \texttt{\_\_init\_\_} to initialize the member variable
      \texttt{mStackElements} as an empty list.
      The object created is then assigned to the variable \texttt{s}.
\item Line 3 defines the first (and in this case only) member variable of the class \texttt{Stack}.
      Therefore, every object $o$ of class \texttt{Stack} will have a \blue{member variable} called
      \texttt{mStackElements}. 
      We will use this list to store the elements of the stack.  To retrieve this member variable from
      an object $o$ we use the following expression:
      \\[0.2cm]
      \hspace*{1.3cm}
      $o$\texttt{.mStackElements}
      \\[0.2cm]
      The implementation of stacks shown
      in Figure \ref{fig:stack-array.stlx} is based on storing the elements of the stack in a
      \textsl{Python} list.  In \textsl{Python}, lists are internally implemented as arrays.  However,
      this is not the only way to implement a stack: A stack can also be implemented as a linked list.
      We will see how to to this later.
\item The rest of the class definition contains a number of function definitions.  Function defined inside
      a class are called \blue{methods}.  These methods are available in the class \texttt{Stack}.  For example,
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{stack.push}
      \\[0.2cm]
      refers to the method \texttt{push} defined in line 5 and 6. Every object of class
      \texttt{Stack} has access to these 
      methods.  For example, if $s$ is an object of class \texttt{Stack}, then we can invoke the
      method \texttt{push} by writing:
      \\[0.2cm]
      \hspace*{1.3cm}
      $s$\texttt{.push($x$)}
\item Line 5 starts the definition of the method \texttt{push}.  This method is called with two arguments:
      \begin{enumerate}[(a)]
      \item \texttt{self} refers to the \texttt{Stack} object.
      \item $e$ is the element that is to be pushed on the stack.  In the array based
            implementation, this is achieved by appending $e$ to the list \texttt{mStackElements}.
      \end{enumerate} 
      When invoking the method \texttt{push}, we have to specify the stack by prefixing it to the method
      invocation.  That is, if $s$ is a stack and we want to push $e$ onto this stack, then we can do this by
      writing: 
      \\[0.2cm]
      \hspace*{1.3cm}
      $s\texttt{.push}(e)$
\item Line 8 starts the implementation of the method \texttt{pop}, which has the task to remove 
      one element from the stack.  Of course, it would not make sense to remove an element from the
      stack if the stack is empty.  Therefore, the \texttt{assert} statement in line 9 checks
      whether the number of elements of the list \texttt{mStackElements} is bigger than $0$.
      If this condition is satisfied, the last element of the list \texttt{mStackElements} is removed.
\item Line 12 starts the definition of the method \texttt{top}.  First, it is checked that the stack
      is non-empty.  Then, the element at the end of the list \texttt{mStackElements} is returned.
\item Line 16 defines the method \texttt{isEmpty}.  This method checks whether the list
      \texttt{mStackElements} is empty.
\item Line 19 defines the method \texttt{copy}.  The purpose of this method is to create an exact
      copy of the given stack.  To this end the method creates a new object $C$ of class \texttt{Stack}.
      Then the member variable \texttt{mStackElements} of the object \texttt{self} that was used to invoke
      the method \texttt{copy} is copied into the member variable \texttt{mStackElements} of the object $C$.

      Note that in order to create a copy $C$ a stack object $S$ it is not sufficient to use the assignment statement
      \\[0.2cm]
      \hspace*{1.3cm}
      $C = S$
      \\[0.2cm]
      because after this statement $C$ is merely a new \blue{reference} to the stack object $S$.  Hence changing $C$
      would also change $S$ and vice versa.  For example, the method call
      \\[0.2cm]
      \hspace*{1.3cm}
      $C.\texttt{pop}()$
      \\[0.2cm]
      would then also pop the stack $S$ and similarly the statement
      \\[0.2cm]
      \hspace*{1.3cm}
      $S.\texttt{push}(x)$
      \\[0.2cm]
      would push $x$ onto the stack $C$.  Since this is usually not what we want, we have to invoke the method
      \texttt{copy} as 
      \\[0.2cm]
      \hspace*{1.3cm}
      $C = S.\texttt{copy}()$
      \\[0.2cm]
      in order to create a copy of the stack $S$.
\item Line 24 defines the method \texttt{\_\_str\_\_}.  This method serves a similar purpose as the method
      \texttt{toString} in a \textsl{Java} program:  If an object of class \texttt{Stack} needs to
      be converted into a string, then the method \texttt{\_\_str\_\_} is invoked automatically to
      perform this conversion.

      In order to understand the implementation of \texttt{\_\_str\_\_} we execute the following statements:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{s = stack(); s.push(1); s.push(2); s.push(3); print(s)}
      \\[0.2cm]
      These statements create an empty stack and push the numbers 1, 2, and 3 
      onto this stack.  Finally, the resulting stack is printed.  The string that is then printed
      is the result of calling \texttt{\_\_str\_\_} and has the following form:
      \begin{verbatim}
      -------------
      | 1 | 2 | 3 |
      -------------
      \end{verbatim}
      \vspace*{-0.5cm}
      Hence, the topmost element of the stack is printed last.

      The implementation of the method \texttt{\_\_str\_\_} works as follows.
      \begin{enumerate}
      \item First, we use the auxiliary method \texttt{\_convert}.  This method computes a string of
            the form \\[0.2cm]
            \hspace*{1.3cm} \texttt{| 1 | 2 | 3 |}. 
            \\[0.2cm]
            The implementation of \texttt{\_convert} is done via a case distinction:
            If the given stack is empty, the result of \texttt{\_convert} will be the string ``\texttt{|}''.  
            Otherwise we get the top element $t$ of the stack using the method \texttt{top()} and remove
            it using \texttt{pop()}.  Next, the remaining stack is converted to a string 
            recursively and finally the element $t$ is appended to this string.

            The name of the method \texttt{\_convert} starts with an underscore because
            \texttt{\_convert} is a \blue{private} method of the class \texttt{Stack}, i.e.~it should not be
            used from outside of the class \texttt{Stack}: Only methods defined in the class \texttt{Stack} are
            permitted to use the method \texttt{\_convert}.  However, this restriction is not enforced by the
            \textsl{Python} interpreter.
      \item The method \texttt{\_\_str\_\_} creates a line of dashes in line 27.
            This line has the same length as the string produced by \texttt{\_convert}.
            The result of \texttt{\_convert} is then decorated with these dashes.
      \end{enumerate}
\item The function $\texttt{createStack}(L)$ converts a list $L$ into a stack and returns the resulting
      \texttt{Stack} object.
\end{enumerate}
You should note that we were able to implement  the method \texttt{\_\_str\_\_} without knowing anything
about the internal representation of the stack.  In order to implement \texttt{\_\_str\_\_} we only used
the methods \texttt{top}, \texttt{pop}, and \texttt{isEmpty}.  This is one of the main advantages of
an abstract data type: An abstract data type abstracts from the concrete data structures that
implement it.  If an abstract data type is done right, it can be used without knowing how the data
that are administered by the abstract data type are actually represented.


\section{Evaluation of Arithmetic Expressions}
Next, in order to demonstrate the usefulness of stacks, we show how \blue{arithmetic expressions} can be
evaluated using stacks.  To this end, we present the
\href{https://en.wikipedia.org/wiki/Shunting-yard_algorithm}{shunting-yard algorithm}\index{shunting-yard algorithm} 
for 
parsing arithmetic expressions.  
For our purposes, an \blue{arithmetic expression} is a string that is made up of natural numbers and
the operator symbols ``\texttt{+}'', ``\texttt{-}'', ``\texttt{*}'', ``\texttt{/}'',
``\texttt{\symbol{37}}'', and ``\texttt{**}''. Here, the operator ``\texttt{/}'' denotes integer division,
while $x \;\texttt{\symbol{37}}\; y$ denotes the remainder of the integer division of $x$ by $y$.  The expression $x\;\texttt{**}\;y$ denotes the power $x^y$.
Furthermore, arithmetic expressions can use the parentheses ``\texttt{(}'' and ``\texttt{)}''.
  
Formally, the set of arithmetic expressions is defined by induction.
\begin{enumerate}
\item Every string that represents a number $n \in \mathbb{N}$ is an arithmetic expression.
\item If $s$ and $t$ are arithmetic expressions, then the string
      \\[0.2cm]
      \hspace*{1.3cm}
      $s+\texttt{'*'}+t$
      \\[0.2cm]
      is an arithmetic expression.  In the expression given above, the first and the last plus symbol
      denote string concatenation, while \texttt{'*'} denotes the string consisting of the multiplication
      operator. 

      Similarly the strings  
      \\[0.2cm]
      \hspace*{1.3cm}
      $s + \texttt{'+'} + t$, \quad $s + \texttt{'-'} + t$, \quad
      $s + \texttt{'/'} + t$, \quad $s + \texttt{'\symbol{37}'} + t$, \quad and \quad $s +\texttt{'**'} + t$
      \\[0.2cm]
      are arithmetic expressions.  We interpret  $s + \texttt{'/'} + t$ as the \blue{integer division} of $s$
      by $t$.
\item If the string $s$ is an arithmetic expression, then the string
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{'('}+ s + \texttt{')'}$ 
      \\[0.2cm]
      is an arithmetic expression.
\end{enumerate}
If we have been given a string that is an arithmetic expression, then in order to \blue{evaluate} this
arithmetic expression we need to know the \blue{precedence}\index{precedence} and the
\blue{associativity}\index{associativity} of the operators.
In mathematics the operators ``\texttt{*}'', ``\texttt{/}'' and ``\texttt{\symbol{37}}'' have a
higher precedence than the operators ``\texttt{+}'' and ``\texttt{-}'':  For example, the expression
$x+y*z$ is interpreted as $x + (y * z)$.
 Furthermore, the operator
  ``\texttt{**}'' has a precedence that is higher than the precedence
 of any other operators.  The operators
``\texttt{+}'', ``\texttt{-}'', ``\texttt{*}'', ``\texttt{/}'', and ``\texttt{\symbol{37}}''
\blue{associate to the left}:  An expression of the form 
\\[0.2cm]
\hspace*{1.3cm} 
\texttt{1 - 2 - 3} \quad is interpreted as \quad \texttt{(1 - 2) - 3}.
 \\[0.2cm]
Finally, the operator ``\texttt{**}'' \blue{associates to the right}:
The arithmetic expression \\[0.2cm]
\hspace*{1.3cm} 
\texttt{2 \texttt{**} 3 \texttt{**}  2} \quad is interpreted as \quad 
\texttt{2 \texttt{**} (3 \texttt{**} 2)}. 
\\[0.2cm]
Our goal is to implement a program that evaluates an arithmetic expression.


\subsection{A Simple Example}
Before we dive into to the details of the shunting-yard algorithm, we present a
simple example.  Consider the arithmetic expression 
\\[0.2cm]
\hspace*{1.3cm} 
``\texttt{1 + 2 * 3 - 4}''. 
\\[0.2cm]
First, this string is transformed into the list of \blue{tokens}
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[1, \symbol{34}+\symbol{34}, 2, \symbol{34}*\symbol{34}, 3, \symbol{34}-\symbol{34}, 4]}.
\\[0.2cm]
A \blue{token} is either a number, an operator symbol, or a parenthesis.
Notice that the space symbols that have been present in the original arithmetic expression string
have been discarded.  This list is then processed from left to right, one token
 at a time.  In order to process this list, we use three stacks.
\begin{enumerate}
\item The  \blue{token list} contains all the tokens of the arithmetic expression.  It is
      initialized with the list of tokens resulting from the input string.
      Although the token list is really just a list we will represent this list as a stack and call
      this list the \blue{token stack}.
      The first token of the arithmetic expression is on top of this stack.
\item The  \blue{argument stack} contains only numbers and is initially empty.
\item The \blue{operator stack} contains only operator symbols and parentheses and is also initially
      empty.
\end{enumerate}
The evaluation of \texttt{1 + 2 * 3 - 4} proceeds as follows:
\begin{enumerate}
\item In the beginning, the token stack contains the tokens of the arithmetic expression and the other two stacks
      are empty: \\[0.2cm]
      \hspace*{1.3cm} 
      \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3,
        \symbol{34}*\symbol{34}, 2, \symbol{34}+\symbol{34}, 1 ]}, 
      \\[0.2cm]
      Note that the number that is at the beginning of the arithmetic expression is on top of the
      stack, i.e.~it is the last element of the list.  \\[0.2cm]
      \hspace*{1.3cm} \texttt{mArguments = []}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mOperators = []}. 
\item The number \texttt{1} is removed from the token stack and is put onto the argument stack
      instead.  The three stacks are now as follows: \\[0.2cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3, \symbol{34}*\symbol{34}, 2, \symbol{34}+\symbol{34} ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1 ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mOperators = []}. 
\item Next, the operator \texttt{\symbol{34}+\symbol{34}} is removed from the token stack and is put
      onto the operator stack.  Then we have: \\[0.2cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3, \symbol{34}*\symbol{34}, 2 ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1 ]} \\[0.2cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34} ]}. 
\item Now, we remove the number \texttt{2} from the  token stack and put it onto the argument stack.
      We have: \\[0.2cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3, \symbol{34}*\symbol{34} ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1, 2 ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34} ]}. 
\item We remove the operator \texttt{\symbol{34}*\symbol{34}} from the  token stack and compare the
      \blue{precedence} of the operator \texttt{\symbol{34}*\symbol{34}} with the precedence of the operator
      \texttt{\symbol{34}+\symbol{34}}, which is on top of the operator stack.  Since the precedence of the operator 
      \texttt{\symbol{34}*\symbol{34}} is greater than the precedence of the operator 
      \texttt{\symbol{34}+\symbol{34}}, the operator \texttt{\symbol{34}*\symbol{34}} is put onto
      the operator stack.  The reason is that we have to evaluate this operator before we can
      evaluate the operator \texttt{\symbol{34}+\symbol{34}}.  Then we have: 
      \\[0.2cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34}, 3 ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1, 2 ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34}, \symbol{34}*\symbol{34}]}. 
\item We remove the number \texttt{3} from the  token stack and put it onto the argument stack.
      \\[0.2cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34} ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1, 2, 3 ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34}, \symbol{34}*\symbol{34} ]}. 
\item We remove the operator \texttt{\symbol{34}-\symbol{34}} from the token stack and
      compare this operator with the operator \texttt{\symbol{34}*\symbol{34}}, which is on top of
      the operator stack.  As the precedence of the  operator \texttt{\symbol{34}*\symbol{34}} is
      higher than the precedence of the operator \texttt{\symbol{34}-\symbol{34}},
      we have to evaluate the operator \texttt{\symbol{34}*\symbol{34}}.  In order to do so, we
      remove the arguments 3 and 2 from the argument stack, remove the operator
      \texttt{\symbol{34}*\symbol{34}} from the operator stack and compute the product of the two
      arguments.  This product is then put back on the 
      argument stack.  The operator \texttt{\symbol{34}-\symbol{34}} is put back on the token stack
      since it has not been used.  Hence, the stacks look as shown below: \\[0.2cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34} ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 1, 6 ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}+\symbol{34} ]}. 
\item Again, we take the operator \texttt{\symbol{34}-\symbol{34}} from the token stack and
      compare it with the operator \texttt{\symbol{34}+\symbol{34}} that is now on top of the
      operator stack.  Since both operators have the same precedence, the operator
      \texttt{\symbol{34}+\symbol{34}} is evaluated:  We remove two arguments from the argument
      stack, remove the operator
      \texttt{\symbol{34}+\symbol{34}} from the operator stack  and compute the sum of the
      arguments.  The result is put back on the argument stack.  Furthermore, the operator
      \texttt{\symbol{34}-\symbol{34}} is put back on the token stack.
      Then we have: \\[0.2cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4, \symbol{34}-\symbol{34} ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 7 ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mOperators = []}. 
\item Next, the operator \texttt{\symbol{34}-\symbol{34}} is removed from the token stack and is now
      put on the operator stack.  We have: \\[0.2cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = [ 4 ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 7 ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}-\symbol{34} ]}. 
\item The number \texttt{4} is removed from the token stack and put onto the argument stack. We have: \\[0.2cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = []}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 7, 4 ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mOperators = [ \symbol{34}-\symbol{34} ]}. 
\item Now the input has been consumed completely.
      Hence, the operator \texttt{\symbol{34}-\symbol{34}} is removed from the  operator stack and
      furthermore, the arguments of this operator are removed from the argument stack.  Then, the
      operator \texttt{\symbol{34}-\symbol{34}} is evaluated and the result is put onto the argument
      stack.  We have: \\[0.2cm]
      \hspace*{1.3cm} \texttt{mTokens \ \ \ = []}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mArguments = [ 3 ]}, \\[0.2cm]
      \hspace*{1.3cm} \texttt{mOperators = []}. \\[0.2cm]
      Therefore, the result of evaluating the arithmetic expression ``\texttt{1+2*3-4}'' is the
      number 3.
\end{enumerate}

\subsection{The Shunting-Yard-Algorithm \label{algo-arith}}
The algorithm introduced in the last example is known as the 
\href{http://en.wikipedia.org/wiki/Shunting-yard_algorithm}{shunting-yard algorithm}.  
\index{shunting-yard algorithm}
This technique is also known as \blue{operator precedence parsing}.\index{operator precedence parsing}
This algorithm was discovered by  \href{http://en.wikipedia.org/wiki/Edsger_Dijkstra}{Edsger Dijkstra} (1930-2002) in
1961.  We give a detailed presentation of this algorithm next.  To begin with, we discuss a couple of auxiliary
function that are needed to implement this algorithm.  The first of these functions is the function
\texttt{toInt}, that is used to convert a string into a natural number, if the string can be interpreted as a
natural number.  For example, the string \texttt{'123'} is converted into the natural number $123$, while the
string \texttt{'**'} is returned unchanged.  Figure \ref{fig:toInt.py} on page \pageref{fig:toInt.py} shows the
implementation of this function:  The function \texttt{int} converts $s$ into a number, provided $s$ the string
$s$ represents an integer.  Otherwise, an Exception of type \texttt{ValueError} is raised.  This exception is
then caught and the string itself is returned.


\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                framesep      = 0.3cm, 
                firstnumber   = 1,
                bgcolor       = sepia,
                numbers       = left,
                numbersep     = -0.2cm,
                xleftmargin   = 0.8cm,
                xrightmargin  = 0.8cm,
              ]{python3}
    def toInt(s):
        try:
            return int(s)   
        except ValueError:
            return s                
\end{minted}
\vspace*{-0.3cm}
\caption{The function \texttt{toInt}.}
\label{fig:toInt.py}
\end{figure}

The function \texttt{tokenize} receives a string $s$ representing an arithmetic expression and splits this
string into a list of numbers and operators. For example, the string \texttt{'1+2*3-4'} is transformed into the list
\\[0.2cm]
\hspace*{1.3cm}
$[4, \texttt{'-'}, 3, \texttt{'*'}, 2, \texttt{'+'}, 1]$.
\\[0.2cm]
The \blue{tokenization} of is achieved using the regular expression that is defined as
\begin{verbatim}
    r'([0-9]+|\*\*|[()+*%/-])'
\end{verbatim}
This string is interpreted as follows:
\begin{enumerate}[(a)]
\item The ``\texttt{r}'' in front of the apostrophe ``\texttt{'}'' specifies that the regular expression is
      defined as a blue{raw string}.  In a raw string the backslash does not have to be
      escaped because it is treated as a literal character.
\item The regular expression itself is divided into three parts.
      These parts are separated by the character ``\texttt{|}''.  This operator is interpreted as a logical or.
      Hence, the regular expression matches any of the following type of strings.
      \begin{enumerate}
      \item ``\texttt{[0-9]+}'' matches a sequence of digits.  For example, it matches ``\texttt{0}'' or
            ``\texttt{123}''.  It would also match a string like ``\texttt{007}''.
            The postfix operator ``\texttt{+}'' at the end of the expression ``\texttt{[0-9]}'' is a
            \blue{quantifier} that specifies that there may be any positive number of characters in the range
            $\{0,\cdots,9\}$.  By itself, the expression ``\texttt{[0-9]}'' only specifies a single character.
            Inside of the expression, the ``\texttt{-}'' serves as a \blue{range operator}.
      \item ``\verb|\*\*|'' matches the operator ``\texttt{**}''.  The character ``\texttt{*}'' has to be
            escaped by a backslash character as this character is also used as a quantifier.
      \item ``\texttt{[()+*/\%-]}'' matches a parenthesis or an arithmetical operator. Note that we have 
            to put the symbol ``\texttt{-}'' last in this group as otherwise this symbol would be 
            interpreted as a \blue{range operator}.
     \end{enumerate}
\end{enumerate}
The method call \texttt{re.findall(regExp, s)} scans the string $s$ for every substring that matches the
given regular expression and collects these substrings into a list.


\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    import re

    def tokenize(s):
        regExp = r'([0-9]+|\*\*|[()+*%/-])'
        L = [ toInt(t) for t in re.findall(regExp, s) ]
        return list(reversed(L))                 
\end{minted}
\vspace*{-0.3cm}
\caption{The function \texttt{tokenize}.}
\label{fig:tokenize.py}
\end{figure}

Next we fix the data structures that are needed for this algorithm.  The class that we will define has three
member variables.
\begin{enumerate}
\item \texttt{mTokens} is a stack of input tokens.  The operator symbols and parentheses are
      represented as strings, while the numbers are represented as rational numbers.  Hence, \texttt{mTokens}
      represents the \blue{token stack}.
\item \texttt{mArguments} is a stack of rational numbers.  Therefore, \texttt{mArguments} represents the
      \blue{argument stack}.
\item \texttt{mOperators} is the \blue{operator stack} containing arithmetic operators.  These operators
      are represented as strings.
\end{enumerate}
Considering the previous example we realize that the numbers appearing in the input tokens are always put onto the argument stack,
while there are two cases for the operator symbols that are part of the input tokens:
\begin{enumerate}
\item We have to put an operator retrieved from the token stack onto the operator stack in all of the following cases:
      \begin{enumerate}
      \item The operator stack is empty.
      \item The operator on top of the operator stack is an opening parenthesis \texttt{\symbol{34}(\symbol{34}}. 
      \item The operator from the token stack has a higher precedence than the operator that is currently on top of the
            operator stack.
      \item The operator from the token stack is the same operator as the operator that is on top of the operator stack and, furthermore,
            this operator associates to the right.
      \end{enumerate}
\item In all other cases, the operator that has been taken from the token stack is put back onto the
      token stack.  In this case, the operator on top of the operator stack is removed from the
      operator stack and, furthermore, the arguments of this operator are removed from the argument
      stack.  Next, this operator is evaluated using the arguments that have been previously removed
      from the argument stack.   The number resulting from this evaluation is then pushed onto the argument stack.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.0cm,
                 xrightmargin  = 0.0cm,
               ]{python3}
    def evalBefore(stackOp, nextOp):
        if stackOp == '(':
            return False
        Precedence = { '+': 1, '-': 1, '*': 2, '/': 2, '%': 2, '**' : 3 }
        if Precedence[stackOp] > Precedence[nextOp]:
            return True
        elif Precedence[stackOp] == Precedence[nextOp]:
            if stackOp == nextOp:
                return stackOp in { '+', '-', '*', '/', '%' }
            else:
                return True
        else:
            return False
\end{minted}
\vspace*{-0.3cm}
\caption{The function \texttt{evalBefore}.}
\label{fig:evalBefore}
\end{figure}


\begin{figure}[!b]
  \centering
\begin{minted}[ frame         = lines, 
                framesep      = 0.3cm, 
                bgcolor       = sepia,
                numbers       = left,
                numbersep     = -0.2cm,
                xleftmargin   = 0.0cm,
                xrightmargin  = 0.0cm,
              ]{python3}
    class Calculator:
        def __init__(self, s):
            self.mTokens    = stack.createStack(tokenize(s))
            self.mOperators = stack.Stack()
            self.mArguments = stack.Stack()
    
        def evaluate(self):
            while not self.mTokens.isEmpty():
                nextOp = self.mTokens.top(); self.mTokens.pop()
                if isinstance(nextOp, int):
                    self.mArguments.push(nextOp)
                    continue
                if self.mOperators.isEmpty() or nextOp == "(":
                    self.mOperators.push(nextOp)
                    continue
                stackOp = self.mOperators.top()
                if stackOp == "(" and nextOp == ")":
                    self.mOperators.pop()
                elif nextOp == ")" or evalBefore(stackOp, nextOp):
                    self.popAndEvaluate()
                    self.mTokens.push(nextOp)
                else:
                    self.mOperators.push(nextOp)
            while not self.mOperators.isEmpty():
                self.popAndEvaluate()
            return self.mArguments.top()
    
        def popAndEvaluate(self):
            rhs = self.mArguments.top(); self.mArguments.pop()
            lhs = self.mArguments.top(); self.mArguments.pop()
            op  = self.mOperators.top(); self.mOperators.pop()
            result = None
            if op == '+':
                result = lhs + rhs
            if op == '-':
                result = lhs - rhs
            if op == '*':
                result = lhs * rhs
            if op == '/':
                result = lhs // rhs
            if op == '%':
                result = lhs % rhs
            if op == '**':
                result = lhs ** rhs
            self.mArguments.push(result)            
\end{minted}
\vspace*{-0.3cm}
  \caption{The class \texttt{Calculator}.}
  \label{fig:Calculator.py}
\end{figure} 
 

\noindent
An implementation of this algorithm in \textsl{Python} is shown in  Figure
\ref{fig:Calculator.py} on page \pageref{fig:Calculator.py}.
We start our discussion of the class \texttt{calculator} by inspecting the function
\texttt{evalBefore} that is shown in Figure \ref{fig:evalBefore}.
This function takes two operators \texttt{stackOp} and \texttt{nextOp} and decides
whether \texttt{stackOp} should be evaluated before \texttt{nextOp}.  Of course, \texttt{stackOp} is
intended to be the operator on top of the operator stack, while \texttt{nextOp} is an operator that
is on top of the token stack.
In order to decide whether the operator \texttt{stackOp} should be evaluated before the operator
\texttt{nextOp},  we first have to know the \blue{precedences} of these operators.  Here, a
\blue{precedence} is a natural number that specifies how strong the operator binds to its
arguments. Table \ref{tab:predence} on page \pageref{tab:predence} lists the precedences of our
operators.  This table is coded as the binary relation \texttt{Precedence} in line 4.

\begin{table}[!h]
  \centering
\framebox{
  \begin{tabular}{|r|r|}
\hline
   Operator             & Precedence  \\
\hline
\hline
   \texttt{\symbol{34}+\symbol{34}}, \texttt{\symbol{34}-\symbol{34}}  & 1   \\
\hline
   \texttt{\symbol{34}*\symbol{34}}, \texttt{\symbol{34}/\symbol{34}}, \texttt{\symbol{34}\symbol{37}\symbol{34}}  & 2   \\
\hline
   \texttt{\symbol{34}**\symbol{34}}  & 3   \\
\hline
  \end{tabular}}
  \caption{Precedences of the operators.}
  \label{tab:predence}
\end{table}

If the precedence of \texttt{stackOp} is bigger than the precedence of \texttt{nextOp}, then we have
to evaluate \texttt{stackOp} before we evaluate \texttt{nextOp}.  On the other hand, if the precedence
of \texttt{stackOp} is smaller than the precedence of \texttt{nextOp}, then we have to push
\texttt{nextOp} onto the operator stack as we have to evaluate this operator before we evaluate \texttt{stackOp}.
If \texttt{stackOp} and \texttt{nextOp} have the same precedence, there are two cases:
\begin{enumerate}
\item $\texttt{stackOp} \not= \texttt{nextOp}$.

      Let us consider an example:  The arithmetic expression 
      \\[0.2cm]
      \hspace*{1.3cm} 
      \texttt{2 + 3 - 4} \quad is processed as \quad \texttt{(2 + 3) - 4}. 
      \\[0.2cm]
      Therefore, in this case we have to evaluate \texttt{stackOp} first.
\item $\texttt{op1} = \texttt{op2}$.

      In this case we have to consider the \blue{associativity} of the operator.
      Let us consider two examples: \\[0.2cm]
      \hspace*{1.3cm} \texttt{2 + 3 + 4} \quad is interpreted as \quad \texttt{(2 + 3) + 4}. \\[0.2cm]
      The reason is that the operator ``\texttt{+}'' \blue{associates to the left}.
      On the other hand, \\[0.2cm]
      \hspace*{1.3cm} 
      \texttt{2 \texttt{**} 3 \texttt{**} 4}  \quad is interpreted as \quad \texttt{2 \texttt{**} (3 \texttt{**} 4)}
      \\[0.2cm]
      because the operator ``\texttt{**}'' \blue{associates to the right}.

      The operators ``\texttt{+}'', ``\texttt{-}'', ``\texttt{*}'', ``\texttt{/}'' and 
      ``\texttt{\symbol{37}}'' are all left associative.  Hence, in this case \texttt{stackOp} is
      evaluated before \texttt{nextOp}.
      The operator ``\texttt{**}'' associates to the right. Therefore, if
      the operator on top of the operator stack is the operator ``\texttt{**}'' and then this operator
      is read again, then we have to push the  operator ``\texttt{**}'' on the operator stack.
\end{enumerate}
Now we can understand the implementation of $\texttt{evalBefore}(\texttt{stackOp},\texttt{nextOp})$.
\begin{enumerate}
\item If \texttt{stackOp} is the opening parenthesis \texttt{\symbol{34}(\symbol{34}}, we have to put
      \texttt{nextOp} onto the operator stack.  The reason is that \texttt{\symbol{34}(\symbol{34}}
      is no operator that can be evaluated.  Hence, we return \texttt{False} in line 3.
\item If the precedence of \texttt{stackOp} is higher than the precedence of \texttt{nextOp}, we
      return \texttt{True} in line 6.
\item If the precedences of \texttt{stackOp} and \texttt{nextOp} are identical, there are two cases:
      \begin{enumerate}
      \item If both operators are equal, then the result of
            \texttt{evalBefore(stackOp,nextOp)} is \texttt{True} if and only if
            this operator associates to the left.  The operators that associate to the left are
            listed in the set in line 9.
      \item Otherwise, if \texttt{stackOp} is different from \texttt{nextOp}, then \\
            \texttt{evalBefore(stackOp,nextOp)} returns \texttt{True}. 
      \end{enumerate}
\item If the precedence of \texttt{stackOp} is less than the precedence of \texttt{nextOp}, then 
      $\texttt{evalBefore(stackOp,nextOp})$ returns \texttt{False}.
\end{enumerate}
Figure  \ref{fig:Calculator.py} on page \pageref{fig:Calculator.py} shows the
implementation of the method \texttt{popAndEvaluate} in line 28.
This method works as follows: 
\begin{enumerate}
\item It takes an operator from the operator stack (line 31), 
\item it fetches the arguments of this operator from the argument stack (line 29 and 30),
\item it evaluates the operator,  and
\item finally puts the result back on top of the argument stack in line 45.
\end{enumerate}
Finally, we are ready to discuss the implementation of the method \texttt{evaluate} in line 7 of
Figure \ref{fig:Calculator.py}.  

\begin{enumerate}
\item First, as long as the token stack is non-empty we take a token from the token stack.
\item If this token is a number, then we put it on the argument stack and continue to read the next token.
  
      In the following code of the \texttt{while} loop that starts at line 13, we can assume that
      the last token that has been read is either an operator symbol
      or one of the parentheses \texttt{\symbol{34}(\symbol{34}} or \texttt{\symbol{34})\symbol{34}}. 
\item If the operator stack is empty or if the token that has been read is an opening parenthesis
      \texttt{\symbol{34}(\symbol{34}}, the operator or parenthesis is pushed onto the operator stack.
\item If the  token that has been read as \texttt{nextOp} is a closing parenthesis 
      \texttt{\symbol{34})\symbol{34}} and, furthermore, the operator on top of the operator stack is
      an opening parenthesis \texttt{\symbol{34}(\symbol{34}}, then this parenthesis is removed from the
      operator stack.
\item If now in line 19 the token \texttt{nextOp} is a closing parenthesis
      \texttt{\symbol{34})\symbol{34}}, then we know that the token on the operator stack
      can't be an opening parenthesis but rather has to be an operator.
      This operator is then evaluated using the method \texttt{popAndEvaluate()}.
      Furthermore, the closing parenthesis \texttt{nextOp} is pushed back onto the
      token stack as we have not yet found the matching open parenthesis.

      After pushing the closing parenthesis back onto the token stack, we return to the beginning of
      the \texttt{while} loop in line 8.  Hence, in this case we keep evaluating operators
      on the operator stack until we hit an opening parenthesis on the operator stack.

      If the operator \texttt{stackOp} on top of the operator stack needs to be evaluated before the operator
      \texttt{nextOp}, we evaluate \texttt{stackOp} using the method \texttt{popAndEvaluate()}.
      Furthermore, the operator \texttt{nextOp} is put back on the token stack 
      as it has not been consumed.  As this is the same thing that happens when 
      the token \texttt{nextOp} is a closing parenthesis, we have combined these two cases.
\item Otherwise, \texttt{nextOp} is put on the operator stack as we need to evaluate it before we evaluate
      \texttt{stackOp}.

      The \texttt{while} loop ends when the token stack gets empty.
\item Finally, the operators remaining on the operator stack are evaluated using
      \texttt{popAndEvaluate}.  If the input has been a syntactically correct arithmetic expression,
      then at the end of the computation there should be one number left on the argument stack.
      This number is the result of the evaluation and hence it is returned.
\end{enumerate}
\pagebreak

\exercise
In the following exercise, your task is to extend the program for evaluating arithmetic expressions in three steps.
\begin{enumerate}[(a)]
\item Extend the program discussed in these lecture notes so that it can also be used to evaluate
      arithmetic expressions containing the function symbols
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{sqrt}, \texttt{exp}, and \texttt{log}.
\item Extend the given program so that the arithmetic expressions may also contain 
      the strings ``\texttt{e}'' and ``\texttt{pi}'', where ``\texttt{e}'' stands for 
      \href{http://en.wikipedia.org/wiki/E_(mathematical_constant)}{Euler's number} 
      while ``\texttt{pi}'' stands for the mathematical constant
      \href{http://en.wikipedia.org/wiki/Pi}{$\pi$} defined as the ratio of the circumference of a
      circle to its diameter. 

      Note that these constants can be accessed in \textsl{Python} via the expressions \texttt{math.e}
      and \texttt{math.pi} provided the module \texttt{math} has been imported.
\item Extend the program so that it can be used to calculate a zero for a given function in a given
      interval $[a,b]$ provided that $f(a) < 0$ and $f(b) > 0$.  
      \eox
\end{enumerate}



\section[Benefits of Abstract Data Types]{Benefits of Using Abstract Data Types}
We finish this chapter with a short discussion of the benefits of abstract data types.
 \begin{enumerate}
 \item The use of abstract data types separates an algorithm from the data structures that
       are used to implement this algorithm.

       When we implemented the algorithm to evaluate arithmetic expressions we did not need to know
       how the data type \blue{stack} that we have used was implemented.  It was sufficient for us to know 
       \begin{enumerate}
       \item the signatures of its functions and
       \item the axioms describing the behaviour of these functions.
       \end{enumerate}
       Therefore, an abstract data type can be seen as an interface that shields the user of the
       abstract data type from the peculiarities of an actual implementation of the data type.
       Hence it is possible that different groups of people develop the algorithm and the
       concrete implementation of the abstract data types used by the algorithm.  

       Today, many software systems have sizes that can only be described as gigantic.  No single
       person is able to understand every single aspect of these systems.  It is therefore important
       that these systems are structured in a way such that different groups of developers can work
       simultaneously on these systems without interfering with the work done by other groups.
 \item Abstract data types are \blue{reusable}.

       Our definition of stacks was very general.  Therefore, stacks can be used in many different
       places:  For example, we will see later how stacks can be used to traverse a directed graph.

       Modern industrial strength programming languages like \texttt{C++} or \textsl{Java} contain
       huge libraries containing the implementation of many abstract data types.  This fact reduces
       the cost of software development substantially.     
 \item Abstract data types are \blue{exchangeable}.

       In our program for evaluating  arithmetic expressions it is trivial to substitute the given
       implementation with an array based implementation of stacks that is more efficient.  In general,
       this enables the following methodology for developing software:  
       \begin{enumerate}
       \item First, an algorithm is implemented using abstract data types.
       \item The initial implementation of these abstract data may be quite crude and inefficient.
       \item Next, detailed performance tests (known as 
             \href{http://en.wikipedia.org/wiki/Profiling_(computer_programming)}{profiling)}
             spot those data types that are performance bottlenecks.
       \item Finally, the implementations of those data types that have been identified as bottlenecks are optimized.
       \end{enumerate}
       The reason this approach works is the 
       \href{http://en.wikipedia.org/wiki/Pareto_principle#In_software}{80-20 rule}:  
       80 percent of the running time of most programs is spent in 20 percent of the code.  It is
       therefore sufficient to optimize the 
       implementation of those data structures that really are performance bottlenecks.  If,
       instead, we would try to optimize everything we would only achieve the following:
       \begin{enumerate}
       \item We would waste our time.  There is no point optimizing some function to make it 10 times
             faster if the program spends less than a millisecond in this function anyway but the
             overall running time is several minutes.
       \item The resulting program would be considerably bigger and therefore more difficult to 
             maintain and optimize.
       \end{enumerate}
 \end{enumerate}

\section{Check Your Understanding}
If you are able to answer the questions below confidently, then you can assume that you have mastered the concepts
introduced in this chapter.
\begin{enumerate}
\item Explain the conceptual idea that underlies \emph{abstract data types}.
\item How have we defined the concept of an \emph{abstract data type} formally?
\item Can you give the formal definition of the abstract data type \textsl{Stack}?
\item How does the shunting-yard algorithm work?
\item What is the benefit of using abstract data types?b
\end{enumerate}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "algorithms"
%%% End: 
