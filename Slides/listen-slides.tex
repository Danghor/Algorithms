\begin{slide}{}
\normalsize

\begin{center}
Einfach verkettete Listen
\end{center}


\rule{17cm}{1mm}

\footnotesize
\vspace*{0.2cm}
Grundidee
\begin{enumerate}
\item Liste: geordnete Ansammlung von Knoten
\item Jeder Knoten besteht aus zwei Komponenten
  \begin{enumerate}
  \item Daten
  \item Zeiger auf n\"achsten Knoten
  \end{enumerate}
\end{enumerate}
Realisierung als \texttt{struct}:
\begin{verbatim}
typedef struct Node* NodePtr;

struct Node {
    Data    data;
    NodePtr nextPtr;
};

typedef NodePtr List;
\end{verbatim}
\begin{enumerate}
\item \texttt{n} letzter Knoten der Liste g.d.w. \texttt{n->nextPtr == 0}
\item Liste wird realisiert durch Zeiger auf Knoten

      \texttt{typedef NodePtr List} wird aus konzeptionellen Gr\"unden
      eingef\"uhrt:  Unterscheidung Knoten $\longleftrightarrow$ Listen.
\item \texttt{Data} wird anderswo \"uber \texttt{typedef} definiert

      dadurch wird Daten--Struktur \texttt{generisch}, 
      d.h.~mehrfach verwendbar
\end{enumerate}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Funktionen auf Knoten und Listen
\end{center}
\vspace*{0.5cm}

\footnotesize
\begin{enumerate}
\item Erzeugung eines Knotens

      \texttt{NodePtr createNode(Data data, NodePtr next);}
\item Anf\"ugen eines Knotens an den Anfang einer Liste

      \texttt{List push(Data data, List l);}
\item L\"oschen einer Liste

      \texttt{void deleteList(List l);}
\item Ausgabe einer Liste

      \texttt{void printList(List l);}
\item Einf\"ugen eines Knotens in sortierte Liste, Liste bleibt dabei sortiert

      \texttt{List insert(NodePtr n, List l);}
\item Sortieren einer Liste

      \texttt{List sortList(List n);}
\item Überpr\"ufung, ob Liste geordnet ist

      \texttt{bool  isOrdered(List l)}
\item Haupt--Programm zum Testen

      \texttt{int main();}
\end{enumerate}


\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize
\begin{center}
  Implementierungen
\end{center}

\footnotesize

\begin{enumerate}
\item Erzeugung eines Knotens

\begin{verbatim}
NodePtr createNode(Data data, NodePtr next) {
    NodePtr nodePtr  = malloc( sizeof(struct Node) );
    nodePtr->data    = data;
    nodePtr->nextPtr = next;
    return nodePtr;
}
\end{verbatim}

\item Anf\"ugen eines Knotens an Listen--Anfang

\begin{verbatim}
List push(Data data, List l) {
    return createNode(data, l);
}
\end{verbatim}


\item L\"oschen einer Liste

\begin{verbatim}
void deleteList(List l) {
    if (l == 0)
        return;
    List rest = l->nextPtr;
    free(l);
    deleteList(rest);
};
\end{verbatim}
\end{enumerate}

Komplexit\"aten: Sei $n$ L\"ange von $l$
\begin{enumerate}
\item \texttt{createNode($d$, $n$)}: $\Oh(1)$
\item \texttt{push($d$, $l$)}: $\Oh(1)$
\item \texttt{void deleteList($l$)}: $\Oh(n)$,
\end{enumerate}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Implementierungen
\end{center}
\vspace*{0.5cm}

\footnotesize
\begin{enumerate}
\item Ausgabe einer Liste

\begin{verbatim}
void printList(List l)
{
    if (l == 0) {
        return;
    }
    printData(l->data);
    printf(" ");
    printList(l->nextPtr);
};
\end{verbatim}

\item Überpr\"ufung, ob Liste geordnet ist

\begin{verbatim}
bool isOrdered(List l) {
    if (l == 0)
        return true;
    if (l->nextPtr == 0)
        return true;
    Data d1 = l->data;
    Data d2 = l->nextPtr->data;
    int cmp = compareData(d1, d2);
    if (cmp <= 0) {
        return isOrdered(l->nextPtr);
    } else {
        return false;
    }
}
\end{verbatim}
\end{enumerate}
Komplexit\"aten: linear.

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Implementierungen
\end{center}
\vspace*{0.5cm}

\footnotesize
\begin{enumerate}
\item Einf\"ugen in sortierte Liste

\begin{verbatim}
List insert(NodePtr n, List l) {
    if (l == 0) {
        n->nextPtr = 0;
        return n;
    }
    int cmp = compareData(n->data, l->data);
    if (cmp <= 0) {
        n->nextPtr = l;
        return n;
    } else {
        NodePtr newNext = insert(n, l->nextPtr);
        l->nextPtr = newNext;
        return l;
    }
}
\end{verbatim}

\item Sortieren

\begin{verbatim}
List sortList(List l) {
    if (l == 0)
        return l;
    NodePtr next   = l->nextPtr;
    NodePtr sorted = sortList(next);
    return insert(l, sorted);
}
\end{verbatim}
\end{enumerate}
Komplexit\"aten:
\begin{enumerate}
\item Einf\"ugen: linear
\item Sortieren: quadratisch
\end{enumerate}


\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Implementierung: Test
\end{center}
\vspace*{0.5cm}

\footnotesize
\begin{verbatim}
typedef unsigned Data;

void printData(Data d) {
    printf("%u", d);
};

int compareData(Data d1, Data d2) {
    if (d1 < d2)            return -1;
        else if (d1 == d2)  return 0;
        else                return +1;    
}   

#include "list.c"

int main() {
    List l = 0;
    for (unsigned i = 0; i < 20; ++i) {
        unsigned number = rand() % 100;
        l = push(number, l);
    }
    printf("The list is:\n");
    printList(l);
    printf("\n");
    printf("Starting to sort now ... \n");
    l = sortList(l);
    printList(l);
    printf("\n");
    assert(isOrdered(l));
    printf("Everything seems to be fine.\n");
    deleteList(l);
    return 0;
}
\end{verbatim}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Min--Sort (Selection Sort)
\end{center}
\vspace*{0.5cm}

\footnotesize
Grundidee
\begin{enumerate}
\item Finde Minimum $m$ einer Liste $l_1$: erhalte \\[0.3cm]
      \hspace*{1.3cm} $m = \mathtt{getMin}(l_1)$
\item L\"osche $m$ aus $l_1$, erhalte \\[0.3cm]
      \hspace*{1.3cm}  $l_2 = \mathtt{delete}(l_1, m)$
\item Sortiere $l_2$ rekursiv, erhalte \\[0.3cm]
      \hspace*{1.3cm}  $l_3 = \mathtt{min\_sort}(l_2)$
\item F\"uge $m$ an den Anfang von $l_3$ an, erhalte \\[0.3cm]
      \hspace*{1.3cm}  $l_4 = \mathtt{cons}(m, l_3)$
\end{enumerate}
Implementierung:
\begin{verbatim}
List minSort(List l1) {
    List l2, l3, l4;
    if (l1 == 0)
        return l1;
    NodePtr m = getMin(l1);
    l2 = delete(l1, m);
    l3 = minSort(l2);
    l4 = cons(m, l3);
    return l4;
}
\end{verbatim}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Min--Sort
\end{center}
\vspace*{0.5cm}

\footnotesize
Implementierung der Hilfs--Funktionen
\begin{verbatim}
NodePtr getMin(List l) {
    assert(l != 0);
    Data first  = l->data;
    if (l->nextPtr == 0) {
        return l;
    }
    NodePtr min_rest = getMin(l->nextPtr);
    Data    rest = min_rest->data;
    int cmp = compareData(first, rest);
    if (cmp <= 0) {
        return l;
    } else {
        return min_rest;
    }
}

List delete(List l, NodePtr ptr) {
    if (l == ptr) {
        return ptr->nextPtr;
    }
    l->nextPtr = delete(l->nextPtr, ptr);
    return l;
}

List cons(NodePtr ptr, List l) {
    ptr->nextPtr = l;
    return ptr;
}
\end{verbatim}
Aufwand \texttt{minSort}: $\Oh(n^2)$ falls $n$ L\"ange der Liste

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Merge--Sort
\end{center}
\vspace*{0.5cm}

\footnotesize
Divide--and--Conquer Algorithmus
\begin{enumerate}
\item Falls Liste $l$ weniger als zwei Elemente hat: \\[0.3cm]
      \hspace*{1.3cm} \texttt{return l;}
\item Sonst: Teile $l$ in zwei Listen $l_1$ und $l_2$ auf. \\[0.3cm]
      \hspace*{1.3cm} \texttt{split(l, \&l1, \&l2);} 
\item Sortiere $l_1$ und $l_2$ rekursiv: \\[0.3cm]
      \hspace*{1.3cm} \texttt{l3 = mergeSort(l1);} \\
      \hspace*{1.3cm} \texttt{l4 = mergeSort(l2);}
\item Mische $l_3$ und $l_4$ so, dass Ordnung erhalten bleibt \\[0.3cm]
      \hspace*{1.3cm} \texttt{l5 = merge(l3, l4);}
\end{enumerate}
Implementierung:
\begin{verbatim}
List mergeSort(List l) {
    if (l == 0 || l->nextPtr == 0)
        return l;
    List l1, l2, l3, l4, l5;
    split(l, &l1, &l2);
    l3 = mergeSort(l1);
    l4 = mergeSort(l2);
    l5 = merge(l3, l4);
    return l5;
}
\end{verbatim}


\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Implementierung der Hilfs--Funktionen
\end{center}
\vspace*{0.5cm}

\footnotesize
Aufspalten einer Liste in zwei Teile
\begin{verbatim}
void split(List l, List* l1_ptr, List* l2_ptr)
{
    if (l == 0) {
        *l1_ptr = 0;
        *l2_ptr = 0;
        return;
    }
    if (l->nextPtr == 0) {
        *l1_ptr = l;
        *l2_ptr = 0;
        return;
    }
    List l1_rest;
    List l2_rest;
    split(l->nextPtr->nextPtr, &l1_rest, &l2_rest);
    NodePtr frst = l;
    NodePtr scnd = l->nextPtr;
    *l1_ptr = cons(frst, l1_rest);
    *l2_ptr = cons(scnd, l2_rest);
}
\end{verbatim}
Eigenschaft: \\[0.3cm]
\hspace*{1.3cm} $x\in l \wedge \mathtt{split}(l, \&l_1, \&l_2) \leftrightarrow x \in l_1 \vee x \in l_2$
 
Wichtig f\"ur Komplexit\"at: Teile sind etwa gleich gro\3 

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Mischen sortierter Listen
\end{center}
\vspace*{0.5cm}

\footnotesize
\begin{verbatim}
List merge(List l1, List l2)
{
    if (l1 == 0) 
        return l2;
    if (l2 == 0) 
        return l1;
    Data d1 = l1->data;
    Data d2 = l2->data;
    int cmp = compareData(d1, d2);
    if (cmp <= 0) {
        return cons(l1, merge(l1->nextPtr, l2));
    } else {
        return cons(l2, merge(l1, l2->nextPtr));
    }
}
\end{verbatim}
Eigenschaften:
\begin{enumerate}
\item $\mathtt{isOrdered}(l_1) \wedge \mathtt{isOrdered}(l_2) \rightarrow \mathtt{isOrdered}(\mathtt{merge}(l_1, l_2)$)
\item $x \in l_1 \vee x \in l_2 \leftrightarrow x \in \mathtt{merge}(l_1, l_2)$
\end{enumerate}

Eigenschaften von \texttt{mergeSort}:
\begin{enumerate}
\item $\mathtt{isOrdered}(\mathtt{mergeSort}(l))$
\item $x\in l \leftrightarrow x \in \mathtt{mergeSort}(l)$
\end{enumerate}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Elementare Operationen
\end{center}
\vspace*{0.5cm}

\footnotesize
\textbf{Idee}: Eine Operation, die vom Prozessor in einem Schritt abgearbeitet werden kann,
ist eine \emph{elementare} Operation.

\textbf{Definition}:  Die folgenden Operationen bezeichnen wir als 
\emph{elementare Operationen}:
\begin{enumerate}
\item Vergleiche: \hspace*{\fill} \texttt{x == y}, \texttt{x < y}
\item Zuweisung:  \hspace*{\fill} \texttt{x = y}
\item Rechen--Operationen:  \hspace*{\fill} \texttt{x + y}, \texttt{x - y}, \texttt{x * y}, \texttt{x / y}
\item Pointer--Zugriff: \hspace*{\fill} \texttt{*n}, \texttt{l->nextPtr}
\item R\"uckgabe eines Ergebnisses: \hspace*{\fill} \texttt{return l}
\item Positionieren eines Arguments auf dem Stack f\"ur einen Funktions--Aufruf
\item Starten des Aufrufs einer Funktion
\end{enumerate}
    Ein Funktions--Aufruf selber ist keine elementare Operation: \\[0.3cm]
\hspace*{1.3cm} \texttt{cons(n, l)} \\[0.3cm]
besteht aus 3 elementaren Operationen
\begin{enumerate}
\item Laden von \texttt{n} auf dem Stack
\item Laden von \texttt{l} auf dem Stack
\item Starten der Funktion
\end{enumerate}


\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Berechnung der Anzahl elementarer Operationen
\end{center}
\vspace*{0.5cm}

\footnotesize
\begin{verbatim}
    List cons(NodePtr ptr, List l) {
        ptr->nextPtr = l;
        return ptr;
    }
\end{verbatim}
\begin{itemize}
\item 2 elementare Operationen um Argumente \texttt{ptr} und \texttt{l} vom Stack zu lesen
\item 1 elementare Operation f\"ur Pointer--Zugriff \\[0.3cm]
      \hspace*{1.3cm} \texttt{ptr->nextPtr}
\item 1 elementare Operation f\"ur Zuweisung \\[0.3cm]
      \hspace*{1.3cm} \texttt{ptr->nextPtr = l}
\item 1 elementare Operation f\"ur Ergebnis--R\"uckgabe  \\[0.3cm]
      \hspace*{1.3cm}  \texttt{return ptr}
\end{itemize}

Also hat ein Aufruf \\[0.3cm]
\hspace*{1.3cm} \texttt{cons(ptr, l)} \\[0.3cm]
in der Summe 8 elementare Operationen zur Folge:
\begin{enumerate}
\item 2 elementare Operationen zum Laden von \texttt{ptr} und \texttt{l} auf Stack
\item 1 elementare Operation zum Starten von \texttt{cons}
\item 5 elementare Operation zum Abarbeiten des Aufrufs
\end{enumerate}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Anzahl der elementaren Operationen f\"ur \texttt{split}
\end{center}
\vspace*{0.5cm}

\footnotesize
$a_n$: Zahl elementaren Operationen bei Aufruf von \texttt{split} \\[0.3cm]
\hspace*{0.8cm} mit Liste der L\"ange $n$

\begin{enumerate}
\item[0.] 3 Argumente auf Stack legen, Funktion starten, 3 Argumente vom Stack 
          lesen: 7 ElOps
\item Fall: \texttt{l == 0}
      
      1 + 2 + 2 + 1 = 6 ElOps

      Also: $a_0 = 6 + 7 = 13$
\item Fall: \texttt{l != 0} und \texttt{l->nextPtr == 0}

      1 + 1 + 2 + 2 + 1 = 7 ElOps

      Also: $a_1 = 7 + 7 = 14$
\item Fall: \texttt{l != 0} und \texttt{l->nextPtr != 0}

      1 + 1 + 4 + $a_{n-2}$ + 1 + 2 + 2 * (2 + 8) ElOps

      Also: $a_{n} = a_{n-2} + 29 + 7 = a_{n-2} + 36$
\end{enumerate}
Wir haben folgende Rekursions--Gleichung:
\begin{enumerate}
\item $a_0 = 13$
\item $a_1 = 14$
\item $a_n = a_{n-2} + 36$
\end{enumerate}


\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
L\"osung der Rekursions--Gleichungen
\end{center}
\vspace*{0.5cm}

\footnotesize
Wir betrachten die F\"alle $n = 2*m$ und $n = 2* m + 1$.
\begin{enumerate}
\item $n = 2 * m$
      $$
      \begin{array}{lcl}
      a_{2 * m} & = & a_{2 * (m-1)} + \underbrace{36}_1 \\
                & = & a_{2 * (m-2)} + \underbrace{36 + 36}_2 \\
                & = & a_{2 * (m-3)} + \underbrace{36 + 36 + 36}_3 \\
                & \vdots &                                  \\    
                & = & a_{2 * (m-i)} + \underbrace{36 + \cdots + 36}_i \\
                & \vdots &                                  \\    
                & = & a_{2 * (m-m)} + \underbrace{36 + \cdots + 36}_m \\
                & = & a_{0} + 36 * m \\[0.3cm]
                & = & 13 + 36 * m \\
      \end{array}
      $$
\item $n = 2 * m + 1$
     
       Dann finden wir analog: \\[0.3cm]
       \hspace*{1.3cm}  $a_{2*m + 1} = 14 + 36 * m$
\end{enumerate}
Setzen wir oben $m = n / 2$, so gilt \\[0.3cm]
\hspace*{1.3cm} $a_n = 13 + 36 * (n/2) + n\,\%\,2 = 13 + 18 * n + n\,\%\,2$ \\[0.3cm]
denn $n\,\%\,2$ ist genau dann 1, wenn $n = 2*m + 1$ ist.

Wir halten fest: \\[0.3cm]
\hspace*{5.3cm} \fbox{$a_n \leq 18 * n + 14$}


\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Zahl der elementaren Operationen von \texttt{merge}
\end{center}
\vspace*{0.5cm}

\footnotesize
$b_{n,m}$: Anzahl elementarer Operationen bei $\texttt{merge}(l_1, l_2)$ falls\\[0.3cm]
\hspace*{1.3cm}  $l_1$ L\"ange $n$ und $l_2$ L\"ange $m$ hat.

\begin{enumerate}
\item Fall: \texttt{l1 == 0}.

      $b_{0,m} = 5 + 2 = 7 \leq 8$
\item Fall: \texttt{l1 != 0} und \texttt{l2 == 0}

      $b_{n,0} = 5 + 1 + 2 = 8$
\item Fall: \texttt{l1 != 0} und \texttt{l2 == 0} 
      \begin{enumerate}
      \item \texttt{cmp <= 0}

            $b_{n,m} = 5 + 2 + 2 + 2 + 8 + 1 + 8 + b_{n-1,m}$
      \item \texttt{cmp > 0}

            $b_{n,m} = 5 + 2 + 2 + 2 + 8 + 1 + 8 + b_{n,m-1}$
      \end{enumerate}
\end{enumerate}
Definere f\"ur \emph{worst case} Absch\"atzung \\[0.3cm]
 $c_{n + m} = b_{n,m} = \left\{ \begin{array}{ll}
                                                 28 + b_{n-1,m} & \mbox{falls}\; \mathtt{cmp} \leq 0 \\[0.2cm]
                                                 28 + b_{n,m-1} & \mbox{falls}\; \mathtt{cmp} > 0 \\
                                                   \end{array} \right\} = 28 + c_{n + m - 1}$ 
\begin{enumerate}
\item $c_0 = 8$
\item $c_{k+1} = c_k + 28$
\end{enumerate}
Dann gilt 
\begin{enumerate}
\item $c_k = 8 + 28 * k$
\item $b_{n,m} \leq c_{n+m} = 8 + 28 * (n + m)$
\end{enumerate}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Zahl der elementaren Operationen von \texttt{mergeSort}
\end{center}
\vspace*{0.5cm}

\footnotesize
$d_n$: Zahl elementare Operationen von $\texttt{mergeSort}(l)$ falls \\
\hspace*{1.3cm} $l$ L\"ange $n$ hat.

Vereinfachung: $n = 2^k$
\begin{enumerate}
\item \texttt{l == 0}
    
       $d_0 = 3 + 1 + 1 = 5$
\item \texttt{l != 0} und \texttt{l->nextPtr == 0}

       $d_1 = 3 + 1 + 1 + 1 + 1 = 7$
\item \texttt{l != 0} und \texttt{l->nextPtr != 0}

      $\begin{array}{lcl}
      d_n &\leq&  3 + 1 + 2 + 18 * n + 14 + 3 + 1 + 2* d_{n/2} +\\
          &    & 8 + 28*(n/2 + n/2) \\[0.3cm]
          & =  &  32 + 46 * n +  2* d_{n/2}  
      \end{array}$

\end{enumerate}
Setze $f_k := d_{2^k}$. Das f\"uhrt auf Rekursions--Gleichung \\[0.3cm]
\hspace*{1.3cm} $f_{k+1} = 32 + 46 * 2^{k+1} + 2 * f_k$ 

Anfangs--Bedingungen
\begin{enumerate}
\item $f_0 = d_1 = 7$
\item $f_1 = 32 + 46 * 2^1 + 2 * f_0 = 32 + 92 + 2*14 = 138$
\item $f_2 = 32 + 46 * 2^2 + 2 * f_1 = 32 + 184 + 2 * 138 = 492$
\end{enumerate}


\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
L\"osung der Rekursions--Gleichung 
\end{center}
\vspace*{0.5cm}

\footnotesize
Ausgangs--Punkt: \\[0.3cm]
\hspace*{1.3cm} $f_{k+1} = 32 + 46 * 2^{k+1} + 2 * f_k$ \hspace*{\fill} (A) 

Setze $k \mapsto k + 1$ \\[0.3cm]
\hspace*{1.3cm} $f_{k+2} = 32 + 46 * 2^{k+2} + 2 * f_{k+1}$ \hspace*{\fill} (B) 

Bilde (B) - (A): \\[0.3cm]
\hspace*{1.3cm} $f_{k+2} - f_{k+1} = 46*2^{k+2} - 46*2^{k+1} + 2 * f_{k+1} - 2 * f_k$

Vereinfachen: \\[0.3cm]
\hspace*{1.3cm} $f_{k+2} = 3 * f_{k+1} - 2 * f_k + 46*2^{k+1}$ \hspace*{\fill} (C)

Setze $k \mapsto k + 1$ \\[0.3cm]
\hspace*{1.3cm}  $f_{k+3} = 3 * f_{k+2} - 2 * f_{k+1} + 46*2^{k+2}$ \hspace*{\fill} (D)

Bilde (D) - 2 * (C) \\[0.3cm]
\hspace*{1.3cm} $f_{k+3} - 2 * f_{k+2} = 3 * f_{k+2} - 6 * f_{k+1} - 2 * f_{k+1} + 4 * f_k$

Vereinfachen:\\[0.3cm]
\hspace*{1.3cm} $f_{k+3} = 5 * f_{k+2} - 8 * f_{k+1} + 4 * f_k$

Characteristisches Polynom: \\[0.3cm]
\hspace*{1.3cm} $\begin{array}{lcl}
                \chi(x) & = & x^3 - 5 * x^2 + 8 * x - 4 \\[0.3cm]
                        & = & (x - 1) * (x - 2)^2 
                \end{array}$


Allgemeine L\"osung: \\[0.3cm]
\hspace*{1.3cm} $f_k = \alpha + \beta * 2^k + \gamma * k * 2^k$


\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
L\"osung der Rekursions--Gleichung (Fortsetzung)
\end{center}
\vspace*{0.5cm}

\footnotesize
Allgemeine L\"osung: \\[0.3cm]
\hspace*{1.3cm} $f_k = \alpha + \beta * 2^k + \gamma * k * 2^k$

Anfangs--Bedingungen liefern lineares Gleichungs-System 
$$
\begin{array}{lrcl}
 k = 0:\quad &   7 & = & \alpha \;+\; \beta \\
 k = 1:\quad & 138 & = & \alpha \;+\; \beta * 2 \,\;\;+\; \gamma * 2 \\
 k = 2:\quad & 492 & = & \alpha \;+\; \beta * 2^2 \;+\; \gamma * 2 * 2^2 \\
\end{array}
$$
L\"osung dies Gleichungs-Systems: \\[0.3cm]
\hspace*{1.3cm} $\alpha = -32, \quad \beta = 39, \quad \gamma = 46$

L\"osung der Rekursions--Gleichung: \\[0.3cm]
\hspace*{1.3cm} $f_k = -32 + 39 * 2^k + 46 * k * 2^k$

Setze $n = 2^k$, also $k = \mathtt{log}_2(n)$ \\[0.3cm]
\hspace*{1.3cm} $d_n = d_{2^k} = f_k = -32 + 39 * n + 46 * \log_2(n) * n$

Ergebnis \\[0.3cm]
\hspace*{3.3cm} \fbox{\fbox{$d_n =  46 * n * \log_2(n) + \Oh(n)$}}
\vspace*{0.5cm}

Die Komplexit\"at von \texttt{Merge--Sort} ist $\Oh(n * \log_2(n))$!

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Verifikation von \texttt{mergeSort}
\end{center}
\vspace*{0.5cm}

\footnotesize
Transformation von \texttt{mergeSort}:
\begin{enumerate}
\item $\mathtt{ms}([]) = []$
\item $\mathtt{ms}([d]) = [d]$
\item $\mathtt{length}(l) \geq 2 \;\rightarrow$ \\[0.3cm]
      $\mathtt{ms}(l) = \mathtt{merge}(\;\mathtt{ms}(\mathtt{split}_1(l)),\; \mathtt{ms}(\mathtt{split}_2(l))\;)$ 
\end{enumerate}
Dabei gilt: \  $ \mathtt{split}(l) = \langle\; \mathtt{split}_1(l), \;\mathtt{split}_2(l) \;\rangle$

Transformation von \textsl{split}:
\begin{enumerate}
\item $\texttt{split}([]) = \langle [], [] \rangle$
\item $\texttt{split}([d]) = \langle [d], [] \rangle$
\item $\texttt{split}([d_1,d_2|r]) = \langle\; [d_1|\mathtt{split}_1(r)],\; [d_2|\mathtt{split}_2(r)] \;\rangle$
\end{enumerate}

Transformation von \textsl{merge}:
\begin{enumerate}
\item $\texttt{merge}([],l) = l$
\item $\texttt{merge}(l,[]) = l$
\item $d_1 \leq d_2 \;\rightarrow \mathtt{merge}([d_1|r_1], [d_2|r_2]) = [d_1| \mathtt{merge}(r_1, [d_2|r_2])]$
\item $d_1 > d_2 \;\rightarrow \mathtt{merge}([d_1|r_1], [d_2|r_2]) = [d_2 | \mathtt{merge}([d_1 | r_1], r_2)]$
\end{enumerate}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Nachweis von $x \in \texttt{ms}(l) \;\leftrightarrow\; x \in l$
\end{center}
\vspace*{0.5cm}

\footnotesize
1. Schritt: Nachweis von 
  $$x \in \texttt{split}_1(l) \vee x \in \textsl{split}_2(l) \;\leftrightarrow \; x \in l $$

Beweis durch \emph{Wertverlaufs--Induktion}:
\begin{enumerate}
\item $l= []$

      $
      \begin{array}{lcl}
        &                 & x \in \mathtt{split}_1([]) \vee x \in \mathtt{split}_2([]) \\[0.3cm]
        & \leftrightarrow & x \in [] \vee x \in [] \\[0.3cm]
        & \leftrightarrow & x \in []
      \end{array}
       $
\item $l = [d]$
    
      $
      \begin{array}{lcl}
 &                 & x \in \mathtt{split}_1([d]) \vee x \in \mathtt{split}_2([d]) \\
 & \leftrightarrow & x \in [d] \vee x \in [] \\
 & \leftrightarrow & x \in [d] \\
      \end{array}
      $
\item $l = [d_1, d_2 | r ]$

      $
      \begin{array}{lcl}
 &                 & x \in \mathtt{split}_1([d_1,d_2|r]) \vee x \in \mathtt{split}_2([d_1,d_2|r]) \\[0.3cm]
 & \leftrightarrow & x \in [ d_1 | \mathtt{split}_1(r) ] \vee x \in [ d_2 | \mathtt{split}_2(r) ] \\[0.3cm]
 & \leftrightarrow & x = d_1 \vee x \in \mathtt{split}_1(r) \vee x = d_2 \vee x \in \mathtt{split}_2(r) \\[0.3cm]
 & \leftrightarrow & x = d_1 \vee x = d_2 \vee x \in \mathtt{split}_1(r) \vee x \in \mathtt{split}_2(r) \\[0.3cm]
 & {IV \atop \displaystyle \leftrightarrow} & x = d_1 \vee x = d_2 \vee x \in r  \\[0.3cm]
 & \leftrightarrow & x \in [d_1, d_2 | r]  
      \end{array}
      $
      
\end{enumerate}


\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Nachweis von $x \in \texttt{ms}(l) \;\leftrightarrow\; x \in l$
\end{center}
\vspace*{0.5cm}

\footnotesize
2. Schritt: Nachweis von
 $$x\in \textsl{merge}(l_1, l_2) \;\leftrightarrow\; x \in l_1 \vee x \in l_2$$

Beweis durch Wertverlaufs--Induktion:
\begin{enumerate}
\item $l_1 = []$

      $x\in \textsl{merge}([], l) \;\leftrightarrow\; x \in l \;\leftrightarrow\; x \in [] \vee x \in l$
\item $l_2 = []$

      $x\in \textsl{merge}(l, []) \;\leftrightarrow\; x \in l \;\leftrightarrow\; x \in l \vee x \in []$
\item $l_1 = [d_1|r_1]$,  $l_2 = [d_2|r_2]$, $d_1 \leq d_2$

      $
      \begin{array}{lcl}
      &                 & x \in \textsl{merge}([d_1|r_1], [d_2|r_2]) \\[0.3cm]
      & \leftrightarrow & x \in [d_1 | \textsl{merge}(r_1, [d_2|r_2])] \\[0.3cm]
      & \leftrightarrow & x = d_1 \vee x \in \textsl{merge}(r_1, [d_2|r_2])] \\[0.3cm]
      & {IV \atop \displaystyle\leftrightarrow} & x = d_1 \vee x \in r_1 \vee x \in [d_2|r_2] \\[0.3cm]
      & \leftrightarrow & x \in [d_1| r_1] \vee x \in [d_2|r_2] 
      \end{array}
      $
\item $l_1 = [d_1|r_1]$,  $l_2 = [d_2|r_2]$, $d_1 > d_2$

      $
      \begin{array}{lcl}
      &                 & x \in \textsl{merge}([d_1|r_1], [d_2|r_2]) \\[0.3cm]
      & \leftrightarrow & x \in [d_2 | \textsl{merge}([d_1|r_1], r_2)] \\[0.3cm]
      & \leftrightarrow & x = d_2 \vee x \in \textsl{merge}([d_1|r_1], r_2)] \\[0.3cm]
      & {IV \atop \displaystyle\leftrightarrow} & x = d_2 \vee x \in [d_1|r_1] \vee x \in r_2 \\[0.3cm]
      & \leftrightarrow & x \in [d_1| r_1] \vee x \in [d_2|r_2] 
      \end{array}
      $
\end{enumerate}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Nachweis von $x \in \texttt{ms}(l) \;\leftrightarrow\; x \in l$
\end{center}
\vspace*{0.5cm}

\footnotesize
Nachweis durch Wertverlaufs--Induktion:
\begin{enumerate}
\item $l = []$

      $x \in \mathtt{ms}([]) \leftrightarrow x \in []$
\item $l = [d]$

      $x \in \mathtt{ms}([d]) \leftrightarrow x \in [d]$
\item $\mathtt{length}(l) \geq 2$

      $
      \begin{array}{lcl}
      &                 & x \in \textsl{ms}(l) \\[0.3cm]
      & \leftrightarrow & x \in \mathtt{merge}(\;\mathtt{ms}(\mathtt{split}_1(l)),\; \mathtt{ms}(\mathtt{split}_2(l))\;) \\[0.3cm]
      & \leftrightarrow & x \in \mathtt{ms}(\mathtt{split}_1(l)) \vee x \in \mathtt{ms}(\mathtt{split}_2(l)) \\[0.3cm]
      &                 &   (\mbox{nach Lemma \"uber \texttt{merge}})                              \\[0.5cm]
      & {IV \atop \displaystyle\leftrightarrow} & x \in \mathtt{split}_1(l) \vee x \in \mathtt{split}_2(l) \\[0.3cm]
      & \leftrightarrow & x \in l  \\[0.3cm]
      &                 &   (\mbox{nach Lemma \"uber \texttt{split}})  
      \end{array}
      $
\end{enumerate}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Nachweis von $\texttt{ordered}(\texttt{ms}(l))$
\end{center}
\vspace*{0.5cm}

\footnotesize
Definition des Pr\"adikats $\mathtt{leq}: \textsl{Data} \times \textsl{List} \rightarrow \mathbb{B}$

\begin{enumerate}
\item $\mathtt{leq}(x,[]) \leftrightarrow \mathtt{true}$
\item $\mathtt{leq}(x,[d|r]) \leftrightarrow x \leq d$
\end{enumerate}

Distributivit\"at von \texttt{leq} und \texttt{merge}: \\[0.3cm]
\hspace*{1.3cm}  $\mathtt{leq}(x, \mathtt{merge}(l_1, l_2)) \leftrightarrow \mathtt{leq}(x,l_1) \wedge \mathtt{leq}(x,l_2)$

Nachweis durch Wertverlaufs--Induktion:
\begin{enumerate}
\item $l_1 = []$:

      $
      \begin{array}{lcl}
        &                 &\mathtt{leq}(x, \mathtt{merge}([], l)) \\[0.3cm]
        & \leftrightarrow & \mathtt{leq}(x, l)                    \\[0.3cm]
        & \leftrightarrow & \mathtt{true} \wedge \mathtt{leq}(x, l) \\[0.3cm]
        & \leftrightarrow & \mathtt{leq}(x, []) \wedge \mathtt{leq}(x, l) \\[0.3cm]
      \end{array}$
\item $l_2 = []$: analog
\item $l_1 = [d_1 | r_1]$, $l_2 = [d_2 | r_2]$, $d_1 \leq d_2$:

      $
      \begin{array}{lcl}
      &                 & \mathtt{leq}(x, \mathtt{merge}([d_1|r_1], [d_2|r_2]))  \\[0.3cm]
      & \leftrightarrow & \mathtt{leq}(x, [d_1 | \mathtt{merge}(r_1, [d_2|r_2])]  \\[0.3cm]
      & \leftrightarrow & x \leq d_1   \\[0.3cm]
      & \leftrightarrow & x \leq d_1 \wedge x \leq d_2  \\[0.3cm]
      &                 & (\mbox{weil $d_1 \leq d_2$})  \\[0.3cm]
      & \leftrightarrow & \mathtt{leq}(x, [d_1|r_1]) \wedge \mathtt{leq}(x, [d_2|r_2])  \\[0.3cm]
      
      \end{array}
      $
\item $l_1 = [d_1 | r_1]$, $l_2 = [d_2 | r_2]$, $d_1 > d_2$: analog
\end{enumerate}


\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Nachweis von $\texttt{ord}(\texttt{ms}(l))$
\end{center}
\vspace*{0.5cm}

\footnotesize
Definition des Pr\"adikats $\mathtt{ord}: \textsl{List} \rightarrow \mathbb{B}$
\begin{enumerate}
\item $\texttt{ord}([]) \leftrightarrow \mathtt{true}$
\item $\texttt{ord}([d|r]) \leftrightarrow \mathtt{leq}(d,r) \wedge \mathtt{ord}(r)$
\end{enumerate}
Distributivit\"at von \texttt{ord} und \texttt{merge}: \\[0.3cm]
\hspace*{1.3cm}  $\mathtt{ord}(\mathtt{merge}(l_1,l_2)) \leftrightarrow \mathtt{ord}(l_1) \wedge \mathtt{ord}(l_2)$

\begin{enumerate}
\item $l_1 = []$: 
      $\begin{array}[t]{lcl}
        &                 & \mathtt{ord}(\mathtt{merge}([],l))   \\[0.3cm]
        & \leftrightarrow & \mathtt{ord}(l)                      \\[0.3cm]
        & \leftrightarrow & \mathtt{true} \wedge \mathtt{ord}(l) \\[0.3cm]
        & \leftrightarrow & \mathtt{ord}([]) \wedge \mathtt{ord}(l) \\[0.3cm]
       \end{array}
      $
\item[3.] $l_1 = [d_1 | r_1]$, $l_2 = [d_2 | r_2]$, $d_1 \leq d_2$:
\vspace*{0.3cm}

\hspace*{-2cm}
      $
      \begin{array}{lcl}
      &                 & \mathtt{ord}(\mathtt{merge}([d_1|r_1], [d_2|r_2])) \\[0.3cm]
      & \leftrightarrow & \mathtt{ord}([d_1|\mathtt{merge}(r_1, [d_2|r_2])]) \\[0.3cm]
      & \leftrightarrow & \mathtt{leq}(d_1, \mathtt{merge}(r_1, [d_2|r_2])) \wedge \mathtt{ord}(\mathtt{merge}(r_1, [d_2|r_2])) \\[0.3cm]
      & \leftrightarrow & \mathtt{leq}(d_1, r_1) \wedge \mathtt{leq}(d_1, [d_2|r_2]) \wedge \mathtt{ord}(\mathtt{merge}(r_1, [d_2|r_2])) \\[0.3cm]
      &                 & (\mbox{wegen der Distributivit\"at von \texttt{leq} und \texttt{merge}})  \\[0.3cm]
      & {IV \atop \displaystyle\leftrightarrow} & 
        \mathtt{leq}(d_1, r_1) \wedge \mathtt{leq}(d_1, [d_2|r_2]) \wedge \mathtt{ord}(r_1) \wedge \mathtt{ord}([d_2|r_2]) \\[0.3cm]
      & \leftrightarrow & \mathtt{leq}(d_1, r_1) \wedge d_1 \leq d_2 \wedge \mathtt{ord}(r_1) \wedge \mathtt{ord}([d_2|r_2]) \\[0.3cm]
      & \leftrightarrow & \mathtt{ord}([d_1|r_1]) \wedge \mathtt{ord}([d_2|r_2]) \\[0.3cm]
      \end{array}
      $
\end{enumerate}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Nachweis von $\texttt{ord}(\texttt{ms}(l))$
\end{center}
\vspace*{0.5cm}

\footnotesize
Nachweis durch Wertverlaufs--Induktion
\begin{enumerate}
\item $l = []$

      $
      \begin{array}{lcl}
        &            & \mathtt{ord}(\mathtt{ms}([])) \\[0.3cm]
        & \leftrightarrow & \mathtt{ord}([])         \\[0.3cm]
        & \leftrightarrow & \mathtt{true}   
      \end{array}
      $
\item $l = [d]$

      $
      \begin{array}{lcl}
        &            & \mathtt{ord}(\mathtt{ms}([d])) \\[0.3cm]
        & \leftrightarrow & \mathtt{ord}([d])         \\[0.3cm]
        & \leftrightarrow & \mathtt{leq}(d, [])       \\[0.3cm]
        & \leftrightarrow & \mathtt{true}   
      \end{array}
      $

\item $\mathtt{length}(l) \geq 2$

      $
      \begin{array}{lcl}
      &                 & \mathtt{ord}(\mathtt{ms}(l))  \\[0.3cm]
      & \leftrightarrow & \mathtt{ord}(\;\mathtt{merge}(\mathtt{ms}(\mathtt{split}_1(l)),\; \mathtt{ms}(\mathtt{split}_2(l))\;) \\[0.3cm]
      & \leftrightarrow & \mathtt{ord}(\mathtt{ms}(\mathtt{split}_1(l))) \wedge \mathtt{ord}(\mathtt{ms}(\mathtt{split}_2(l))) \\[0.3cm]
      &                 & (\mbox{wegen der Distributivit\"at von \texttt{ord} und \texttt{merge}}) \\[0.3cm]
      & {IV \atop \displaystyle\leftrightarrow} & \mathtt{true} \wedge \mathtt{true} \\[0.3cm]
      & \leftrightarrow & \mathtt{true}  \\[0.3cm]
      \end{array}
      $
\end{enumerate}
Insgesamt gezeigt:
\begin{enumerate}
\item $x \in \textsl{ms}(l) \;\leftrightarrow\; x \in l$
\item $\mathtt{ord}(\mathtt{ms}(l))$
\end{enumerate}


\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Verifikation von \texttt{minSort}
\end{center}
\vspace*{0.5cm}

\footnotesize
1. Schritt: Transformation in bedingte Gleichungen

Transformation von \texttt{minSort}:
\begin{enumerate}
\item $\mathtt{minSort}([]) = []$
\item $l \not=[] \rightarrow $\\[0.3cm]
      $\mathtt{minSort}(l) \;=\; [\; \mathtt{getMin}(l) \;|\; \mathtt{minSort}(\,\mathtt{delete}(l, \mathtt{getMin}(l))\,)\;]$
\end{enumerate}
Transformation von \texttt{delete}:
\begin{enumerate}
\item $\texttt{delete}([],d) = []$
\item $d_1 = d_2 \rightarrow \mathtt{delete}([d_1|r_1], d_2) = r_1$
\item $d_1 \not= d_2 \rightarrow \mathtt{delete}([d_1|r_1], d_2) = [\;d_1 \;|\; \mathtt{delete}(r_1, d_2)\;]$
\end{enumerate}
Transformation von \texttt{getMin}:
\begin{enumerate}
\item $\mathtt{getMin}([d]) = d$
\item $d \leq \mathtt{getMin}(r) \rightarrow \mathtt{getMin}([d|r]) = d$
\item $d >    \mathtt{getMin}(r) \rightarrow \mathtt{getMin}([d|r]) = \mathtt{getMin}(r)$
\end{enumerate}
Definition: $\leq : \textsl{Data} \times \textsl{List} \rightarrow \mathbb{B}$
\begin{enumerate}
\item $x \leq []$
\item $x \leq [d|r] \;\leftrightarrow\; x \leq d \wedge x \leq r$
\end{enumerate}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}

\end{center}
\vspace*{0.5cm}

\footnotesize
Definition von \texttt{ordered}:
\begin{enumerate}
\item $\mathtt{ordered}([]) \leftrightarrow \mathtt{true}$
\item $\mathtt{ordered}([d|r]) \leftrightarrow d \leq r \wedge \mathtt{ordered}(r)$
\end{enumerate}

Ben\"otigte Lemmata:
\begin{enumerate}
\item $x \leq y \wedge y \leq l \rightarrow x \leq l$
\item $l \not= [] \rightarrow \bigg(x \leq l \leftrightarrow x \leq \mathtt{getMin}(l)\bigg)$
\item $l \not = [] \rightarrow \mathtt{getMin}(l) \leq l$
\item $x \leq l \rightarrow x \leq \mathtt{delete}(l,y)$
\item $l \not= [] \rightarrow \mathtt{getMin}(l) \leq \mathtt{delete}(l, \mathtt{getMin}(l))$
\item $x \leq l \leftrightarrow x \leq \mathtt{minSort}(l)$
\item $l \not= [] \rightarrow \mathtt{getMin}(l) \leq \mathtt{minSort}(\,\mathtt{delete}(l, \mathtt{getMin}(l))\,)$
\item $y \in l \rightarrow \bigg(x \in l \leftrightarrow x \in \mathtt{delete}(l,y) \vee x = y \bigg)$
\item $l \not= [] \rightarrow \mathtt{getMin}(l) \in l$
\end{enumerate}

S\"atze
\begin{enumerate}
\item $x \in \mathtt{minSort}(l) \leftrightarrow x \in l$
\item $\mathtt{ordered}(\mathtt{minSort}(l))$
\end{enumerate}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Listen  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Naiver Algorithmus
\end{center}
\vspace*{0.5cm}

\footnotesize
\begin{verbatim}
procedure shortest_path(source);
    DistSource := {};
    DistSource(source) := 0;
    while exists [v,w] in Edges | 
        DistSource(v) /= om and 
        ( DistSource(w) = om or 
    DistSource(v) + Distance([v,w]) < DistSource(w)
        )
    loop
        DistSource(w) := DistSource(v) + Distance(v, w);
    end loop;
end shortest_path;
\end{verbatim}

\vspace*{\fill}
\tiny \addtocounter{mypage}{-27}
\rule{17cm}{1mm}
Shortest Path Algorithm  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}{}
\normalsize

\begin{center}
Moore's Algorithmus
\end{center}
\vspace*{0.5cm}

\footnotesize
\begin{verbatim}
procedure moore(source);
    DistSource := {};
    DistSource(source) := 0;
    Fringe := { source };
    while Fringe /= {} loop
        node := arb Fringe;
        distNode := DistSource(node);
        for id in Edges(node) loop
            if DistSource(id) = om then
                DistSource(id) := 
                    distNode + Distance(node, id);
                Fringe        +:= { id };
            else
                oldDist := DistSource(id);
                newDist := 
                    distNode + Distance(node, id);
                if newDist < oldDist then
                    DistSource(id) := newDist;
                    Fringe        +:= { id };
                end if;
            end if;
        end loop;
        Fringe -:= { node };
    end loop;
end moore;
\end{verbatim}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Shortest Path Algorithm  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{slide}{}
\normalsize

\begin{center}
Naiver Algorithmus
\end{center}
\vspace*{0.5cm}

\footnotesize
\begin{verbatim}
procedure dijkstra(source);
    DistSource := {};
    DistSource(source) := 0;
    Fringe := Heap();
    Fringe.insert(0, source);
    while not Fringe.isEmpty() loop
        [ distIdTop, idTop ] := Fringe.top();
        for id in Edges(idTop) loop
            if DistSource(id) = om then
                distId         := 
                    distIdTop + Distance(idTop, id);
                DistSource(id) := distId;
                Fringe.insert(distId, id); 
            else
                oldDist := DistSource(id);
                newDist := 
                    distIdTop + Distance(idTop, id);
                if newDist < oldDist then
                    DistSource(id) := newDist;
                    Fringe.change(id, newDist);
                end if;
            end if;
        end loop;
        Fringe.remove();
    end loop;
end dijkstra;
\end{verbatim}

\vspace*{\fill}
\tiny \addtocounter{mypage}{1}
\rule{17cm}{1mm}
Shortest Path Algorithm  \hspace*{\fill} Seite \arabic{mypage}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "listen.tex"
%%% End: 
